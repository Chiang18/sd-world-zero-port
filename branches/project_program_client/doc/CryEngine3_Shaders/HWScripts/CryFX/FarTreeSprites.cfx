
#include "Common.cfi"
#include "ShadeLib.cfi"
#include "ModificatorVT.cfi"

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script = "ShaderDrawType = Custom;"
                  "ShaderType = General;"
                  "PreprType = GenerateSprites;"
>;

/// Un-Tweakables //////////////////////
float4 SpritesOutdoorAOVertInfo;
float4 TexAtlasSize;

sampler2D BaseSampler  : register(s0);		// linear
sampler2D shadowMaskSampler : register(s1);
{
 Texture = $ScreenShadowMap;
 MinFilter = LINEAR;
 MagFilter = LINEAR;
 MipFilter = NONE;
 AddressU = Clamp;
 AddressV = Clamp;
};

sampler2D sceneAOTargetForSprites : register(s2);

sampler2D TerrainInfoSampler0  : register(s3)
{
  sRGBLookup = true;
};

/////////////////////////////

struct a2v
{
  float4 Position : POSITION; //in object space
  float2 baseTC   : TEXCOORD0;
  IN_C0
};

struct v2f
{
  float4 Position  : POSITION;  //in projection space

#ifdef PS3 || XENON
  float4 baseTC    : TEXCOORD0;
#else
	float4 baseTC    : TEXCOORD0_centroid;
#endif

  float4 OutdoorAOInfo   : TEXCOORD1;

  float4 shadowTC  : TEXCOORD2;
#if %_RT_FOG
  float4 localFogColor : TEXCOORD3;
#endif
  OUT_C0
};

struct v2f_z
{
  float4 Position  : POSITION;  //in projection space

#ifdef PS3 || XENON
  float4 baseTC    : TEXCOORD0;
#else
	float4 baseTC    : TEXCOORD0_centroid;
#endif
  float4 ZInfo     : TEXCOORD1; // w is uzed during impostors gen
};

///////////////// vertex shader //////////////////

v2f_z SpriteVS_Z(a2v IN)
{
  v2f_z OUT;
#ifndef OPENGL  
  OUT = (v2f_z)0; 
#endif

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.Position = mul(g_VS_ViewProjMatr, vPos);

#if %_RT_FSAA
  OUT.ZInfo.xyz = vPos.xyz;
#endif     

  float4 inColor = GetInputColor(IN.Color);
  OUT.baseTC.xy = IN.baseTC.xy;
  OUT.baseTC.z = inColor.b; // pass custom alpha ref

  OUT.ZInfo.w = OUT.Position.w * g_VS_NearFarClipDist.w;

  return OUT;
}

v2f SpriteVS(a2v IN)
{
  v2f OUT;
#ifndef OPENGL  
  OUT = (v2f)0; 
#endif

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.Position = mul(g_VS_ViewProjMatr, vPos);
  
  OUT.baseTC.xy = IN.baseTC.xy;

  OUT.Color = GetInputColor(IN.Color);


  OUT.baseTC.zw = float2(IN.baseTC.x + (OUT.Color.r<0.5 ? TexAtlasSize.w*32 : TexAtlasSize.w*64), IN.baseTC.y); // use higher lod    
  
#if %_RT_FOG
	OUT.localFogColor = GetVolumetricFogColor( vPos );
#endif

  int nQuality = GetShaderQuality();
  if( nQuality > QUALITY_LOW )
  {
	  OUT.OutdoorAOInfo.x = SpritesOutdoorAOVertInfo.z*vPos.y+SpritesOutdoorAOVertInfo.x;
	  OUT.OutdoorAOInfo.y = SpritesOutdoorAOVertInfo.z*vPos.x+SpritesOutdoorAOVertInfo.y;
	  OUT.OutdoorAOInfo.z = vPos.z-SpritesOutdoorAOVertInfo.w; // vertex z relative to terrain sector min z
  }

  OUT.shadowTC = HPosToScreenTC(OUT.Position);

  return OUT;
}


// TODO: vectorize, make simplified version for zpass
half4 tex2DBilinearSprites( sampler2D MapSampler, float2 texTC, half fAlphaRef, 
                           out half fSunContribution, out half fAlpha )
{
  const float4 MapParams = TexAtlasSize;

	// MapParams.xy = texture size
	// MapParams.zw = texture texel size
#ifdef PS3
	if(false)
#else
  if( GetShaderQuality() > QUALITY_LOW )
#endif
  {
	  float2 f = frac( texTC.xy * MapParams.xy );


	  half4 t00 = tex2D( MapSampler, texTC );
    half S00 = (1.0f-t00.a)*(1.0/(1.0-fAlphaRef));
    half fAlpha00 = t00.a>fAlphaRef;

	  half4 t10 = tex2D( MapSampler, texTC + MapParams.zw * float2( 1.0, 0.0 ) );
    half S10 = (1.0f-t10.a)*(1.0/(1.0-fAlphaRef));
    half fAlpha10 = t10.a>fAlphaRef;

	  half4 tA = lerp( t00, t10, f.x );
    half SA = lerp( S00, S10, f.x );
    half fAlphaA = lerp( fAlpha00, fAlpha10, f.x );


	  half4 t01 = tex2D( MapSampler, texTC + MapParams.zw * float2( 0.0, 1.0 ) );
    half S01 = (1.0f-t01.a)*(1.0/(1.0-fAlphaRef));
    half fAlpha01 = t01.a>fAlphaRef;

	  half4 t11 = tex2D( MapSampler, texTC + MapParams.zw * float2( 1.0, 1.0 ) );
    half S11 = (1.0f-t11.a)*(1.0/(1.0-fAlphaRef));
    half fAlpha11 = t11.a>fAlphaRef;

	  half4 tB = lerp( t01, t11, f.x );
	  half SB = lerp( S01, S11, f.x );
    half fAlphaB = lerp( fAlpha01, fAlpha11, f.x );


    fSunContribution = lerp( SA, SB, f.y );
    fAlpha = lerp( fAlphaA, fAlphaB, f.y );

	  return lerp( tA, tB, f.y );
  }
  else
  {
    half4 cSprite = tex2D( MapSampler, texTC);
    
    fSunContribution = (1.0h-cSprite.a)*(1.0h/(1.0h-fAlphaRef));   
    fAlpha = cSprite.a>fAlphaRef;
      
	  return cSprite;
  }

}

///////////////// pixel shader //////////////////

half4 GetTerrainColor(sampler2D s, float2 terrainTC, float fTerrNdotL, float shadowOccl, float fSkyBr, float SSAOVal)
{
	half4 terrainInfo = tex2DTerrain(s, terrainTC);

#if %_RT_AMBIENT_OCCLUSION
	float fSkyAccess = lerp(terrainInfo.a,1.f,fSkyBr);
#else
	float fSkyAccess = SSAOVal;
#endif

	terrainInfo.xyz = terrainInfo.xyz * (g_PS_SunColor.xyz*fTerrNdotL*(1-shadowOccl) + g_PS_SkyColor.xyz * fSkyAccess); 
	return terrainInfo;
}

pixout SpritePS(v2f IN)
{
  pixout OUT;
#if PS3
  // suggested by gpad
  #pragma sce-cgc("-regcount 16"); 
#endif


  int nQuality = GetShaderQuality();
  
	half SpriteAlphaRef = 0.1h;
	
	#if %_RT_NOZPASS
		#ifdef PS3
				SpriteAlphaRef = IN.Color.x;	// TODO Please check if inColor.b should be IN.Color.x in general
		#else
				SpriteAlphaRef = IN.Color.b;
		#endif
	#endif
   
  // load the base
  half fSunContribution, fAlpha;
  half4 baseColor = tex2DBilinearSprites(BaseSampler, IN.baseTC.xy, SpriteAlphaRef, fSunContribution, fAlpha); 

	// LDR->HDR transformation, 10.0f allows 10x brightness
  baseColor.xyz *= IN.Color.w * 10.0h;
	
	half shadowOccl = 1.0h;
	#if !%_RT_AMBIENT
		shadowOccl = tex2Dproj(shadowMaskSampler, IN.shadowTC.xyzw).x;
	#endif

	half3 vAORatios = 1.h;

  bool bAO = false;

  // Only need AO in case deferred disabled - ambient term already with AO.
  //  note: with deferred ambient no need to store sprite ambient anymore - can now get more precision/data there
  if( bAO )
  {
    // apply screen space AO ambient AND partially to diffuse
    half4 vAO = tex2Dproj(sceneAOTargetForSprites, IN.shadowTC.xyzw);    
    vAORatios = vAO.x * vAO.y * vAO.w;
  }

   // Debug output
 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, IN.baseTC);
   return OUT;
 #endif

	// split sun and sky components
	half3 vSun = baseColor;
	half3 vAmb = baseColor;

	// apply real-time shadows
	vSun *=(1-shadowOccl) * vAORatios.y;
	vAmb *= vAORatios.x;

	// combine final color
	//baseColor.rgb = vSun + vAmb;
	baseColor.rgb= lerp(vAmb, vSun, fSunContribution);

  if( nQuality > QUALITY_LOW )
  {

#ifdef %_RT_BLEND_WITH_TERRAIN_COLOR
	half4 terrainColor = GetTerrainColor(TerrainInfoSampler0, IN.OutdoorAOInfo.xy, IN.Color.g, shadowOccl, 0, vAORatios.x);
	baseColor.xyz = lerp(terrainColor.xyz, baseColor.xyz, 0.5f);
#endif

  }

	half3 vFinalDif = baseColor.xyz;

  // note: this is needed to avoid artefacts - but for consoles we might be able to skip - test
  //clip(fAlpha - .5h);

#if %_RT_FOG
  OUT.Color.xyz = lerp(IN.localFogColor.xyz, vFinalDif.xyz, IN.localFogColor.w);
#else  
  OUT.Color.xyz = vFinalDif.xyz;
#endif
	

  OUT.Color.w = fAlpha;

  HDROutput(OUT, OUT.Color, 1);

#if PS3
  #if %_RT_HDR_MODE
    OUT.Color = EncodeHDRBuffer( OUT.Color );
  #endif  
#endif
  

  //OUT.Color.rgb = 1;//1-shadowOccl;//float3(0,0,1);
  //OUT.Color.a = 1;
  
  return OUT;
}

// 2 textures sprites version (Sun and Amb)
pixout Sprite2PS(v2f IN)
{
  pixout OUT;
  int nQuality = GetShaderQuality();
  
  half SpriteAlphaRef = 0.1;
  
  #if %_RT_NOZPASS
    #ifdef PS3
     SpriteAlphaRef = IN.Color.x;	// TODO Please check if inColor.b should be IN.Color.x in general
    #else
     SpriteAlphaRef = IN.Color.b;
    #endif
  #endif
   
  // load the base
  half4 vSun = tex2D(BaseSampler, IN.baseTC.xy);
  half4 vAmb = tex2D(BaseSampler, IN.baseTC.zw);
  half fAlpha = vSun.a;
  //clip(fAlpha - .5f);

  //OUT.Color.xyz = vAmb.xyz;
  //return OUT;
  
  half shadowOccl = 1.0h;
  #if !%_RT_AMBIENT
    shadowOccl = tex2Dproj(shadowMaskSampler, IN.shadowTC.xyzw).x;
  #endif

	half3 vAORatios = 1.f;

  bool bAO = false;
  if( nQuality == QUALITY_HIGH )
    bAO = true;

#if D3D10
  bAO = true;
#endif

  if( bAO )
  {
    // apply screen space AO ambient AND partially to diffuse
    half4 vAO = tex2Dproj(sceneAOTargetForSprites, IN.shadowTC.xyzw);    
    vAORatios = vAO.x * vAO.y * vAO.w;
  }

   // Debug output
 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, IN.baseTC);
   return OUT;
 #endif

	// apply real-time shadows
	vSun *= (1-shadowOccl) * vAORatios.y;
	vAmb *= vAORatios.x;

	// combine final color
  half3 vFinalDif = vSun + vAmb;

  if( nQuality > QUALITY_LOW )
  {
#ifdef %_RT_BLEND_WITH_TERRAIN_COLOR
    half4 terrainColor = GetTerrainColor(TerrainInfoSampler0, IN.OutdoorAOInfo.xy, IN.Color.g, shadowOccl, 0, vAORatios.x);
    vFinalDif.xyz = lerp(terrainColor.xyz, vFinalDif.xyz, 0.5f);
#endif
  }

  clip(fAlpha - .5f);

#if %_RT_FOG
  OUT.Color.xyz = lerp(IN.localFogColor.xyz, vFinalDif.xyz, IN.localFogColor.w);
#else  
  OUT.Color.xyz = vFinalDif.xyz;
#endif
  OUT.Color.w = fAlpha;

  HDROutput(OUT, OUT.Color, 1);

#if PS3
  #if %_RT_HDR_MODE
    OUT.Color = EncodeHDRBuffer( OUT.Color );
  #endif  
#endif
  
  return OUT;
}

pixout SpriteFuncPS(v2f IN)
{
#if PS3
  #pragma sce-cgc("-texformat default COMPRESSED_RGBA_S3TC_DXT5");  
#endif

#if %_RT_SAMPLE1        // 2 textures sprite
  return Sprite2PS(IN);
#else
  return SpritePS(IN);
#endif
}

pixout SpritePS_Z(v2f_z IN)
{
  pixout OUT;

	half SpriteAlphaRef = IN.baseTC.z;

  // load the base
  half fSunContr, fAlpha;
  half4 baseColor = tex2DBilinearSprites(BaseSampler, IN.baseTC.xy, SpriteAlphaRef, fSunContr, fAlpha);
  
  float fZ = IN.ZInfo.w; 
  float4 ret = EncodeSceneDepthWithAlpha(fZ, fAlpha, .5h, IN.ZInfo.xyz);

	// on consoles we always use alpha test 
#if PS3 || XENON
	ret.a = half(fAlpha > .5h);
#endif
  OUT.Color = ret;  

  return OUT;
}

pixout Sprite2PS_Z(v2f_z IN)
{
  pixout OUT;

  half4 vSun = tex2D(BaseSampler, IN.baseTC.xy);
  half fAlpha = vSun.a;
  half fZ = IN.ZInfo.w; 
  float4 ret = EncodeSceneDepthWithAlpha(fZ, fAlpha, 0.5f, IN.ZInfo.xyz);
  
  OUT.Color = ret;  

  return OUT;
}

pixout SpriteZFuncPS(v2f_z IN)
{
#if PS3
  #pragma sce-cgc("-texformat default COMPRESSED_RGBA_S3TC_DXT5");  
  #pragma sce-cgc("-fastprecision");  
#endif

#if %_RT_SAMPLE1        // 2 textures sprite
  return Sprite2PS_Z(IN);
#else
  return SpritePS_Z(IN);
#endif
}

//////////////////////////////// technique ////////////////

technique General
<
  string Script = 
        "TechniqueZ=General_Z;"        
>
{
  pass p0
  {
    VertexShader = compile vs_Auto SpriteVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto SpriteFuncPS() SpritePS;
  }
}

technique General_Z
{
  pass p0
  {
    VertexShader = compile vs_Auto SpriteVS_Z();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto SpriteZFuncPS() SpritePS;
  }
}

v2f Sprite_DebugVS(a2v IN)
{
  v2f OUT;
#ifndef OPENGL  
  OUT = (v2f)0; 
#endif

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.Position = float4(
			2.0f * (vPos.xy + 0.5f) / float2(64, 64) - 1.0f, vPos.zw);
  
  OUT.baseTC.xy = IN.baseTC.xy;
  
  float4 inColor = GetInputColor(IN.Color);
  OUT.Color = inColor;
  
  return OUT;
}

pixout Sprite_DebugPS(v2f IN)
{
  pixout OUT;
  int nQuality = GetShaderQuality();
  
	half SpriteAlphaRef = 0.1h;
	
	#if %_RT_NOZPASS
	  SpriteAlphaRef = IN.Color.b;
	#endif
   
  // load the base
  half fSunContribution, fAlpha;
  half4 baseColor = tex2DBilinearSprites(BaseSampler, IN.baseTC.xy, SpriteAlphaRef, fSunContribution, fAlpha); 
	half3 vFinalDif = baseColor.xyz;

  //clip(fAlpha - .5f);

  OUT.Color.xyz = vFinalDif.xyz;
  OUT.Color.w = fAlpha;

  HDROutput(OUT, OUT.Color, 1);

  //OUT.Color.rgb = float3(0,0,1);
  //OUT.Color.a = 1;
  
  return OUT;
}

technique General_Debug
{
  pass p0
  {
    VertexShader = compile vs_Auto Sprite_DebugVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto Sprite_DebugPS();
  }
}

#include "ShadowCommon.cfi"
#include "CommonShadowPass.cfi"

/////////////////////// eof ///



