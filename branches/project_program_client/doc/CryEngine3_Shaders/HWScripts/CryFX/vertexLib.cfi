////////////////////////////////////////////////////////////////////////////
//
//  Crytek Engine Source File.
//  Shader extension
//  Copyright (C), Crytek Studios, 2001-2004.
// -------------------------------------------------------------------------
//  File name:   VertexLib.cfi
//  Version:     v1.00
//  Created:     08/07/2006 by Tiago Sousa
//  Compilers:   
//  Description: Common vertex shader. Since almost all techniques share a similar
//  vertex shader, a common vertex shader has been created to save some work/code lines
//  and as an optimization at same time. 
//
//  Notes:
//    - When adding new features here, make sure it works with instancing
//
// -------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////

#if !%TEMP_VEGETATION

 #define INST_STREAM_CUSTOM                          \
  #if %_RT_INSTANCING_ATTR                           \
    float4 InstAmbientOp  : TEXCOORDN;               \
   #if %_RT_FOG                                      \
    float4 InstAvgFogVolumeContrib   : TEXCOORDN;    \
   #endif                                            \
  #endif                                             \
  
#endif

///////////////// Vertex/texture modifiers //////////////////

#include "ModificatorVT.cfi"
#include "ModificatorTC.cfi"

///////////////// General vertex output //////////////////

struct vert2FragGeneral
{  
  OUT_P
  float4 baseTC     : TEXCOORDN;
  

#if %_RT_FOG ||%_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D || %DECAL
  float4 Ambient   : TEXCOORDN;
#endif

#if %_RT_FOG || %ANISO_SPECULAR 
    float4 vTangent  : TEXCOORDN;
    float4 vBinormal : TEXCOORDN;
#endif

  float4 vView     : TEXCOORDN;       
  
#ifdef PS3 || XENON
  float4 screenProj : TEXCOORDN;   //z used for instanced alpha test value
#else
	float4 screenProj : TEXCOORDN_centroid;   //z used for instanced alpha test value
#endif

#if %_LT_LIGHTS && %_LT_HASPROJ  
  float4 projTC     : TEXCOORDN;
#endif    

#if %_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D
  float3 DistAtten : TEXCOORDN;
#endif  

#if %_RT_FOG && (!%_RT_DECAL_TEXGEN_2D && !%_RT_DECAL_TEXGEN_3D)
  float4 AvgFogVolumeContrib : TEXCOORDN;
#endif

#if %VERTCOLORS || %DIRTLAYER || %BLENDLAYER
	float4 Color      : COLOR0;
#endif

};

///////////////// Shared vertex shader computations //////////////////

void vs_shared_output( in app2vertGeneral IN, inout vert2FragGeneral OUT, inout streamPos vertPassPos, bool bUseBump )
{
  // Common data
  
  streamPos_FromGeneral(IN, vertPassPos);
  float4 vPosDecal = vertPassPos.Position;
  
  OUT.HPosition = Pos_VS_General(g_VS_ViewProjZeroMatr, vertPassPos);     
  float3 vNorm = vertPassPos.ObjToTangentSpace[2];

  float4 baseTC = vertPassPos.baseTC;
#if %_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D
	_TCModifyDecal( vertPassPos, baseTC, OUT.DistAtten );
#endif

  // Apply texture modifiers
 _TCModify(baseTC, OUT.baseTC, vertPassPos.Position, vNorm, TS_DIFFUSE);
 
 if (bUseBump)
 {
   float4 bumpTC;
   _TCModify(baseTC, bumpTC, vertPassPos.Position, vNorm, TS_BUMP);
   OUT.baseTC.zw = bumpTC.xy;
 } 

#if %_RT_FOG ||%_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D || %DECAL

  // Output ambient color - for alpha blending, recursive rendering passes, decals also require ambient.w (opacity parameter)
   OUT.Ambient = AmbientOp;

  #if %_RT_INSTANCING_ATTR
    #fetchinst (OUT.Ambient = IN.InstAmbientOp, vertPassPos.nInstance);
  #endif

#endif

#if %_RT_FOG || %ANISO_SPECULAR

    // Output tangents only for cases that require it - alpha blending, recursive passes and anisotropic specular

    // Note: Normalization required for normal diffuse map in world space in case scale used - Do not remove
    float3 worldTangentS = normalize( mul((const float3x3)vertPassPos.InstMatrix, vertPassPos.ObjToTangentSpace[0]) );
    float3 worldTangentT = normalize( mul((const float3x3)vertPassPos.InstMatrix, vertPassPos.ObjToTangentSpace[1]) );
    float3 worldTangentN = (cross(worldTangentS, worldTangentT)) * vertPassPos.Tangent.w;
    
    OUT.vTangent = float4(worldTangentS, vertPassPos.Tangent.w); 
    OUT.vBinormal.xyz = worldTangentT;

#endif

  OUT.vView.xyz = vertPassPos.WorldPos.xyz;
#if %_RT_OBJ_IDENTITY
  OUT.vView.xyz -= g_VS_WorldViewPos.xyz;
#else
  vertPassPos.WorldPos.xyz += g_VS_WorldViewPos.xyz;
#endif
  
  // Output the screen-space texture coordinates - for shadows and general projections
  OUT.screenProj = HPosToScreenTC(OUT.HPosition);

   // Output projection
#if %_LT_LIGHTS && %_LT_HASPROJ  
  OUT.projTC = mul(LightMatrix, vertPassPos.WorldPos);
#endif	 

  // Output fog into view-vector W component (to save interpolator)
#if %_RT_FOG && (!%_RT_DECAL_TEXGEN_2D && !%_RT_DECAL_TEXGEN_3D)
  OUT.vView.w = GetVolumetricFogDensity(OUT.vView.xyz + g_VS_WorldViewPos.xyz);

 #if %_RT_INSTANCING_ATTR
   #fetchinst (OUT.AvgFogVolumeContrib = IN.InstAvgFogVolumeContrib, vertPassPos.nInstance);  
 #else
   OUT.AvgFogVolumeContrib = AvgFogVolumeContrib;
 #endif

 #if !%_RT_ALPHABLEND
    // additive blending case
    OUT.AvgFogVolumeContrib.w *= OUT.vView.w;
    OUT.AvgFogVolumeContrib.xyz = 0.0;
 #endif
#else
  OUT.vView.w = vertPassPos.Position.w;    
#endif

#if %VERTCOLORS || %DIRTLAYER || %BLENDLAYER
  OUT.Color = vertPassPos.Color;
#endif

}

/////////////////////// eof ///
