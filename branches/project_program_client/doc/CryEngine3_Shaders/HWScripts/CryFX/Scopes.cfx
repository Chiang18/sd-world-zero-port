
#include "Common.cfi"
#include "ShadeLib.cfi"
#include "ModificatorVT.cfi"
#include "ModificatorTC.cfi"

#if %REFLEX_SIGHT
  #if %REFLEX_SIGHT_NEW
    #undefine %REFLEX_SIGHT_NEW
  #endif    
#endif

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "Public;"             
           "ShaderDrawType = General;"
#if !%REFLEX_SIGHT_NEW
					 "AfterHDRPostProcess;"
					 "ForceDrawLast;"
#endif
           "ShaderType = FX;"
>;

////////////////////////////////////////////////////////////////

float4  AnimGenParams = { PB_time 1.0, PB_time 0.5, PB_time 0.25, PB_time 0.125};

float4 RandGenParams : PB_RandomParams;
float4 GlowParams : PB_GlowParams;


sampler2D reflexSightSampler 
{ 
  Texture = $Diffuse;   
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE; 
  AddressU = Clamp;
  AddressV = Clamp;   
	sRGBLookup = true; 
};

sampler2D noiseMapSampler
{
  Texture = textures\defaults\JumpNoiseHighFrequency_x27y19.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = POINT; 
  AddressU = Wrap;
  AddressV = Wrap;	
};

/// Specific data ////////////////////////

#if %REFLEX_SIGHT || %REFLEX_SIGHT_NEW

float ScopeScale
<  
  psregister = PS_REG_PM_3.x;
  string UIName = "Scope scale";        
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 100.0;
  float UIStep = 0.05;
> = 4;

float NoiseScale
<  
  psregister = PS_REG_PM_3.z;
  string UIName = "Noise scale";        
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 1.0;
  float UIStep = 0.05;
> = 0.75;

#if %REFLEX_SIGHT_NEW

	float ScopeColorMultiplier
	<  
		psregister = PS_REG_PM_3.y;
		string UIName = "Scope color multiplier";        
		string UIWidget = "slider";
		float UIMin = 0.0;
		float UIMax = 16.0;
		float UIStep = 0.05;
	> = 4;

	float NoiseBias
	<  
		psregister = PS_REG_PM_3.w;
		string UIName = "Noise bias";        
		string UIWidget = "slider";
		float UIMin = 0.0;
		float UIMax = 1.0;
		float UIStep = 0.05;
	> = 1.0;

	float HolographicNoiseScale
	<  
		psregister = PS_REG_PM_4.x;
		string UIName = "Holographic noise scale";        
		string UIWidget = "slider";
		float UIMin = 0.0;
		float UIMax = 1.0;
		float UIStep = 0.05;
	> = 0.0;

	float FakeGlowAmount
	<  
		psregister = PS_REG_PM_4.y;
		string UIName = "Fake glow amount";        
		string UIWidget = "slider";
		float UIMin = 0.0;
		float UIMax = 8.0;
		float UIStep = 0.05;
	> = 0.25;

#else

	float ScopeColorMultiplier
	<  
		psregister = PS_REG_PM_3.y;
		string UIName = "Scope color multiplier";        
		string UIWidget = "slider";
		float UIMin = 0.0;
		float UIMax = 256.0;
		float UIStep = 0.05;
	> = 160;

#endif

#endif


///////////////// vertex shader //////////////////

struct v2Frag
{
  float4 HPosition : POSITION;
  float2 baseTC    : TEXCOORDN;    
  float4 screenPos : TEXCOORDN;  
};

///////////////// vertex shader //////////////////
v2Frag ScopeVS(app2vertGeneral IN)
{
  v2Frag OUT = (v2Frag)0; 

  // Position in screen space.
  streamPos vertPassPos = (streamPos)0;
  streamPos_FromGeneral(IN, vertPassPos);

  OUT.HPosition = Pos_VS_General(g_VS_ViewProjZeroMatr, vertPassPos);

  OUT.baseTC.xy=vertPassPos.baseTC.xy;
  
  // Output projected refraction texture
	OUT.screenPos = HPosToScreenTC( OUT.HPosition );

  return OUT;
}

///////////////// pixel shader //////////////////

pixout ScopePS(v2Frag IN)
{
  pixout OUT = (pixout) 0;

  half4 cFinal = 1;

#if %REFLEX_SIGHT_NEW

	 // Screen noise
	 float2 tcProj = (IN.screenPos/IN.screenPos.w) ;
   half fNoise = saturate( tex2D(noiseMapSampler, tcProj *(PS_ScreenSize.xy/ 64) + RandGenParams.xy)); 
   fNoise += tex2D(noiseMapSampler, (tcProj *(PS_ScreenSize.xy/ 64) + 0.5 - RandGenParams.zw));
	 fNoise = saturate( fNoise - 1.0 );
	 half fScopeNoise = saturate(NoiseBias + fNoise * saturate(NoiseScale));

   half fAspectRatio = 0.75;

	 float2 tcDiffuse = saturate( (tcProj - 0.5)*(ScopeScale+ ScopeScale * HolographicNoiseScale* (fNoise*2-1))*float2(1,fAspectRatio) + 0.5 );
	 half fEdgeAtten = saturate( 1 - dot(tcDiffuse * 2 - 1, tcDiffuse * 2 - 1) );

	 // Fetch, sum up and apply noise
   cFinal = tex2D(diffuseMapSampler, tcDiffuse );
	 // Add simple fake glow
   cFinal += FakeGlowAmount * ( tex2Dbias(diffuseMapSampler, float4(tcDiffuse, 0, 2) ) );

	 //// Add fake glow (use triangle filter + tex bias)
  // cFinal += FakeGlowAmount * ( tex2Dbias(diffuseMapSampler, float4(tcDiffuse + ResInfoDiffuse.zw * float2( 0,  1), 0, 2) ) +
		//													  tex2Dbias(diffuseMapSampler, float4(tcDiffuse + ResInfoDiffuse.zw * float2( 1, -1), 0, 2) ) +
		//													  tex2Dbias(diffuseMapSampler, float4(tcDiffuse + ResInfoDiffuse.zw * float2(-1, -1), 0, 2) ) );

	 cFinal *= fEdgeAtten * fScopeNoise;

	 cFinal *= ScopeColorMultiplier;

	 cFinal.xyz += cFinal.xyz * GlowParams;

   cFinal.w = saturate(cFinal.w);

	 // save some rop on PS3
	 clip(cFinal.w - 1.0h / 255.h);

#elif %REFLEX_SIGHT

	 // Kept for backward compatibility

   float2 tcProj = (IN.screenPos/IN.screenPos.w) ;
   half fNoise = tex2D(noiseMapSampler, tcProj *(PS_ScreenSize.xy/ 64) + AnimGenParams.x);
   fNoise += tex2D(noiseMapSampler, (tcProj *(PS_ScreenSize.xy/ 64) - AnimGenParams.x)*1.05);
   fNoise *= 0.5;

   half fAspectRatio = 0.75;// * PS_ScreenSize.x / PS_ScreenSize.y;

   
   float2 tcReflSight =  (tcProj - 0.5)*(ScopeScale + NoiseScale * ScopeScale * (fNoise*2-1))*float2(1,fAspectRatio) + 0.5;
   tcReflSight = saturate( tcReflSight );

   // add fake glow
   NoiseScale = 1;
   ScopeScale *= 0.25;
   float2 tcReflSightGlow =  (tcProj - 0.5)*(ScopeScale + NoiseScale * ScopeScale * (fNoise*2-1))*float2(1,fAspectRatio) + 0.5;
   tcReflSightGlow = saturate( tcReflSightGlow );

   cFinal = tex2D(reflexSightSampler, tcReflSight );
   cFinal += 0.25 * tex2D(reflexSightSampler, tcReflSightGlow );
   cFinal.w = saturate( cFinal.w *0.75);

#endif

  HDROutput(OUT, cFinal, 1);
   
  return OUT;
}

//////////////////////////////// technique ////////////////

technique General
{
  pass p0
  {    
    VertexShader = compile vs_Auto ScopeVS() GeneralVS;
    PixelShader = compile ps_Auto ScopePS() GeneralPS;

    ZEnable = true; 
    ZFunc = LEqual; 
    ZWriteEnable = false; 
    CullMode = None;

#if %REFLEX_SIGHT_NEW || %REFLEX_SIGHT

#if %REFLEX_SIGHT_NEW
    SrcBlend = SRC_ALPHA;
#else
		SrcBlend = ONE; 
#endif

    DestBlend = ONE_MINUS_SRC_ALPHA;
    AlphaBlendEnable = true;        
    IgnoreMaterialState = true;
#endif

  }
}

/////////////////////// eof ///
