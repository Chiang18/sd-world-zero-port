
//define %TEMP_TERRAIN 0x40000000

#define VS_NO_SKINNING_DATA

#include "Common.cfi"
#include "TerrainValidations.cfi"

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
#if %DETAIL_BUMP_MAPPING
					 "DetailBumpMapping;"
#endif

           "SupportsDeferredShading;"
#if !%ENVIRONMENT_MAP
					 "SupportsFullDeferredShading;"
#endif

           "ShaderDrawType = Terrain;"
           "ShaderType = Terrain;"
>;

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Custom shading pass structure /////////////////////////////////////

struct fragPassCustom
{
  half3 vTangent;        // perturbed tangent vector
  half3 vBinormal;       // perturbed binormal vector
  half3 cEnvironment;    // environment map
  half fDiffuseAlpha;    // layer alpha
  half4 Color1;
};

struct fragLightPassCustom
{
#ifdef PS3
	float4 Dummy;
#endif
};

#include "ShadeLib.cfi"


//=============================================================

/// Un-Tweakables //////////////////////

float4 BaseTCMatrix    : PB_TerrainBaseMatrix;
half4 AmbientOpPB        : PB_AmbientOpacity;

// Terrain layer constants:
float4x4 LayerTexGen      : PB_TerrainLayerGen;

//=========================================================================

// Tweakables /////////////////
#if %ENVIRONMENT_MAP

  // EnvMap amount
  float EnvMapAmount
  <
    psregister = PS_REG_PM_3.x;
    string UIHelp = "Set amount of reflection"; 
    string UIWidget = "slider";
    string UIName = "Reflect Amount";
    float UIMin = 0.0;
    float UIMax = 10.0;
    float UIStep = 0.01;
  > = 0.25;
  
  // Fresnel parameters
  float FresnelScale
  <
    psregister = PS_REG_PM_3.y;
    string UIHelp = "Set fresnel term scale"; 
    string UIWidget = "slider";
    string UIName = "Fresnel Scale";
    float UIMin = 0.0;
    float UIMax = 32.0;
    float UIStep = 0.01;
  > = 1;

  float FresnelBias
  <
    psregister = PS_REG_PM_3.z;
    string UIWidget = "slider";
    string UIHelp = "Set how much reflective material is"; 
    string UIName = "Fresnel Bias";  
    
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.001;
  > = 0;

#endif

float DetailTextureStrength
<
  psregister = PS_REG_PM_3.w;
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 2.0;
  float UIStep = 0.05;
> = 1;


#if %OFFSETBUMPMAPPING
float ObmDisplacement
<
  psregister = PS_REG_PM_4.x;
  string UIWidget = "slider";
  string UIName = "OBM Displacement";
  float UIMin = 0.0;
  float UIMax = 0.025;
  float UIStep = 0.001;
> = 0.004;
#endif

#if %EXPOSE_POM_MAT_PARAMS
float PomDisplacement
<
  psregister = PS_REG_PM_5.x;
  string UIWidget = "slider";
  string UIName = "POM Displacement";
  float UIMin = 0.0;
  float UIMax = 0.05;
  float UIStep = 0.001;
> = 0.025;

float SelfShadowStrength
<
  psregister = PS_REG_PM_5.y;
  string UIWidget = "slider";
  string UIName = "Self shadow strength";
  float UIMin = 0.0;
  float UIMax = 5.0;
  float UIStep = 0.1;
> = 3.0;
#endif

#if %DETAIL_BUMP_MAPPING
	float DetailBumpTillingU
	<
	  psregister = PS_REG_PM_6.x;
	  string UIHelp = "Set detail diffuse_bump tilling";                     
	  string UIName = "Detail tilling U";
	  string UIWidget = "slider";
	  float UIMin = 0.0;
	  float UIMax = 32.0;
	  float UIStep = 0.1;
	> = 1.0;
	
	float DetailBumpTillingV
	<
	  psregister = PS_REG_PM_6.y;
	  string UIHelp = "Set detail diffuse_bump tilling";                     
	  string UIName = "Detail tilling V";
	  string UIWidget = "slider";
	  float UIMin = 0.0;
	  float UIMax = 32.0;
	  float UIStep = 0.1;
	> = 1.0;
	
	float DetailBumpScale
	<
	  psregister = PS_REG_PM_6.z;
	  string UIHelp = "Set detail bump scale";                     
	  string UIName = "Detail bump scale";    	  
	  string UIWidget = "slider";
	  float UIMin = 0.0;
	  float UIMax = 10.0;
	  float UIStep = 0.1;
	> = 1.0;
	
	float DetailBlendAmount
	<
	  psregister = PS_REG_PM_6.w;
	  string UIHelp = "Set diffuse detail blend scale";                     
	  string UIName = "Detail blend amount";    	  
	  string UIWidget = "slider";
	  float UIMin = 0.0;
	  float UIMax = 1.0;
	  float UIStep = 0.1;
	> = 0.0;
#endif


///////////////////////////////
// Samplers
sampler2D baseMapSampler = sampler_state
{
  Texture = $FromRE0;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
	sRGBLookup = true; 
};

sampler2D lmMapSampler = sampler_state
{
  Texture = $FromRE1;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

sampler2D baseMap_FromContainerSampler = sampler_state
{
  Texture = $FromRE0_FromContainer;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
	//sRGBLookup = true; 
};

sampler2D lmMap_FromContainerSampler = sampler_state
{
  Texture = $FromRE1_FromContainer;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

sampler2D envMapSampler = sampler_state
{ Texture = $EnvironmentCubeMap; };
samplerCUBE envMapSamplerCUBE = sampler_state
{
	Texture = $EnvironmentCubeMap;
	AddressU = Clamp;
  AddressV = Clamp;
};

//==========================================================================

struct vert2fragTerrain
{
  OUT_P
  float4 baseTC     : TEXCOORDN; // z is used as fLinearDistanceToCameraInMeters during impostor gen
#ifdef PS3 || XENON
  float4 screenProj : TEXCOORDN;
#else
	float4 screenProj : TEXCOORDN_centroid;
#endif
  
  half4 vNormal    : TEXCOORDN; // w contain baked shadows fading

  OUT_C0

#if !%_RT_OBJ_IDENTITY
  OUT_C1
#endif
};

struct vert2fragLayer
{
  OUT_P
  float4 basesectorTC : TEXCOORDN;		// xy=surface texture, zw=occlusionmap texture (so save interpolators)
  float4 baseTC			  : TEXCOORDN;		// terrain normal/diffuse/spec texture

  float3 tangVec    : TEXCOORDN;
  float3 binormVec  : TEXCOORDN; 


  float3 normalVec  : TEXCOORDN; 
  float4 Pos        : TEXCOORDN;

#ifdef PS3 || XENON
  float4 screenProj : TEXCOORDN;
#else
  float4 screenProj : TEXCOORDN_centroid;
#endif
 
#if %_LT_LIGHTS && %_LT_HASPROJ  
  float4 projTC     : TEXCOORDN;
#endif

  OUT_C0
  OUT_C1
};

#include "vertexLib.cfi"

///////////////// terrain vertex shader //////////////////
vert2fragTerrain TerrainVS(app2vertGeneral IN)
{
  vert2fragTerrain OUT = (vert2fragTerrain)1; 

  streamPos vertPassPos = (streamPos)0;
  streamPos_FromGeneral(IN, vertPassPos);

  // Apply modificators if needed
  OUT.HPosition = Pos_VS_Terrain(0.001f, g_VS_ViewProjZeroMatr, vertPassPos);
  
#if !%_RT_OBJ_IDENTITY
  vertPassPos.WorldPos.xyz += g_VS_WorldViewPos.xyz;
#endif

  // tex coordinates on the sector textures
  OUT.baseTC.x = dot(float4(0, BaseTCMatrix[0], 0, BaseTCMatrix[1]), vertPassPos.WorldPos);
  OUT.baseTC.y = dot(float4(BaseTCMatrix[0], 0, 0, BaseTCMatrix[2]), vertPassPos.WorldPos);
	OUT.baseTC.z = BaseTCMatrix[0];
  OUT.baseTC.w = vertPassPos.WorldPos.z;

  OUT.Color = vertPassPos.Color;
  
#if !%_RT_OBJ_IDENTITY
	OUT.Color1 = float4(OUT.Color.xz, vertPassPos.Normal.ww);
	OUT.Color1.a = (OUT.Color.g>=0.5) ? 1 : 0;
#endif

	// Output the screen-space texture coordinates
  OUT.screenProj = HPosToScreenTC(OUT.HPosition);
  
  OUT.vNormal.xyz = vertPassPos.Normal.xyz;
  
#if %_RT_FOG
  float4 fogColor = GetVolumetricFogColor(vertPassPos.WorldPos.xyz);
  OUT.vNormal.w = fogColor.w;
#endif

  return OUT;
}

//===================================================================================

///////////////// terrain vertex shader //////////////////
vert2fragLayer TerrainLayerVS(app2vertGeneral IN)
{
  vert2fragLayer OUT;
#ifndef OPENGL  
  OUT = (vert2fragLayer)0; 
#endif
  
  streamPos vertPassPos = (streamPos)0;
  streamPos_FromGeneral(IN, vertPassPos);
  
  // Apply modificators if needed
  OUT.HPosition = Pos_VS_Terrain(0.001f, g_VS_ViewProjZeroMatr, vertPassPos); 

#if !%_RT_OBJ_IDENTITY
  vertPassPos.WorldPos.xyz += g_VS_WorldViewPos.xyz;
#endif

	// tex coordinates on the sector textures
  OUT.basesectorTC.x = dot(float4(0, BaseTCMatrix[0], 0, BaseTCMatrix[1]), vertPassPos.WorldPos);
  OUT.basesectorTC.y = dot(float4(BaseTCMatrix[0], 0, 0, BaseTCMatrix[2]), vertPassPos.WorldPos);
  OUT.basesectorTC.z = BaseTCMatrix[0];          
	
  float4 tcLayer;

	float3 vDiffPos = vertPassPos.WorldPos.xyz;
	vDiffPos.xy -= LayerTexGen[3].xy;
  tcLayer.xy = mul((float2x3)LayerTexGen, vDiffPos);
  tcLayer.z = 0;
  tcLayer.w = vertPassPos.Position.w;
  _TCModify(tcLayer, OUT.baseTC, vertPassPos.Position, vertPassPos.Normal, TS_DIFFUSE);
  

	float3 vBumpPos = vertPassPos.WorldPos.xyz;
	vBumpPos.xy -= LayerTexGen[3].zw;
  tcLayer.xy = mul((float2x3)LayerTexGen, vBumpPos);
  float4 bumpTC;
  _TCModify(tcLayer, bumpTC, vertPassPos.Position, vertPassPos.Normal, TS_BUMP);
  OUT.baseTC.zw = bumpTC.xy;

  // get tangent space info from texgen parameters
  float3 Tangent = normalize(LayerTexGen[0].xyz);
  float3 Binormal = normalize(LayerTexGen[1].xyz);
  
  // project tangent and binormal to plane perpendicular to the normal
  Tangent-=dot(Tangent,vertPassPos.Normal)*vertPassPos.Normal;
  Binormal-=dot(Binormal,vertPassPos.Normal)*vertPassPos.Normal;
  Tangent=normalize(Tangent);
  Binormal=normalize(Binormal);

  OUT.tangVec.xyz = Tangent;    
  OUT.binormVec.xyz = Binormal;

  OUT.Pos.xyz = vertPassPos.WorldPos.xyz - g_VS_WorldViewPos.xyz;
  OUT.normalVec.xyz = vertPassPos.Normal.xyz;

#ifdef %_LT_LIGHTS && %_LT_HASPROJ  
   OUT.projTC = mul(LightMatrix, vertPassPos.WorldPos);
#endif          

	float fUseVertColor = 0;
	
	float4 Color = vertPassPos.Color;

	if (Color.g > 127.f/255.f)
	{
		fUseVertColor = 1;
		Color.g -= 128.f/255.f;
	}

  float fWeight = saturate(1 - abs(Color.g*255 - LayerTexGen[2].w));	// saturate needed for dx10 HDR

  if( GetShaderQuality() > QUALITY_LOW )
  {
    float3 NormalAbs = abs(vertPassPos.Normal.xyz); 
    if(NormalAbs.x>=NormalAbs.y && NormalAbs.x>=NormalAbs.z)
		  fWeight *= LayerTexGen[2].x;
    else
    if(NormalAbs.y>=NormalAbs.x && NormalAbs.y>=NormalAbs.z)
		  fWeight *= LayerTexGen[2].y;
	  else
		  fWeight *= LayerTexGen[2].z;
  }
  else
  {
    if(dot(abs(vertPassPos.Normal.xyz),LayerTexGen[2].xyz) < 0.55f)
      fWeight = 0;
  }
  
 	// Output the screen-space texture coordinates
  OUT.screenProj = HPosToScreenTC(OUT.HPosition);


  OUT.Color1 = float4(Color.rb, vertPassPos.Normal.ww);
  OUT.Color.a = Color.a; // pass ambient occlusion

	OUT.Color1.a = fUseVertColor;

  float fDist = length(OUT.Pos.xyz);

  OUT.basesectorTC.w = fDist;
 
  fDist = pow(min(fDist/max(0.001, LayerTexGen[0].w), 1), 4);
  OUT.Color.g = fWeight * (1-fDist);

#if %_RT_FOG
  float4 fogColor = GetVolumetricFogColor(vertPassPos.WorldPos.xyz);
  OUT.Pos.w = fogColor.w;
#endif

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_unify_parameters( inout fragPass pPass )
{

  pPass.bRenormalizeNormal = true;
  pPass.bHemisphereLighting = true;
  pPass.bDeferredSpecularShading = true;

#if %OFFSETBUMPMAPPING || %PARALLAX_OCCLUSION_MAPPING
  #if %PARALLAX_OCCLUSION_MAPPING
    pPass.bParallaxOcclusionMapping = true;
    pPass.fBumpHeightScale = PomDisplacement;
    pPass.fSelfShadowStrength = SelfShadowStrength;
  #elif %OFFSETBUMPMAPPING
    pPass.bOffsetBumpMapping = true;
    pPass.fBumpHeightScale = ObmDisplacement;
  #endif
#endif

#if %ENVIRONMENT_MAP
  #if %_TT3_TCUBE
    pPass.nReflectionMapping = REFLECT_CUBE;
  #else
    pPass.nReflectionMapping = REFLECT_SPHERE;  
  #endif    
  
  pPass.fReflection_Amount = EnvMapAmount;
  pPass.fFresnel_Bias = FresnelBias;
  pPass.fFresnel_Scale = FresnelScale;
    
#endif  

#if %DETAIL_BUMP_MAPPING
	pPass.bDetailBumpMapping = true;
	pPass.vDetailBumpTilling = half2(DetailBumpTillingU, DetailBumpTillingV);
	pPass.fDetailBumpScale = DetailBumpScale;
	pPass.fDetailBlendAmount = DetailBlendAmount;
#endif

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


void frag_unify(inout fragPass pPass, in vert2fragLayer IN)
{
  frag_unify_parameters( pPass );
  
  pPass.IN.baseTC = IN.baseTC;
  pPass.IN.bumpTC.xy = pPass.IN.baseTC.zw;
  pPass.IN.basesectorTC = IN.basesectorTC;

  pPass.IN.vTangent.xyz = IN.tangVec;
  pPass.IN.vBinormal.xyz = IN.binormVec;

  pPass.IN.vNormal.xyz = IN.normalVec;
  pPass.IN.vView = IN.Pos;
  pPass.IN.screenProj = IN.screenProj;
  pPass.IN.Color = IN.Color;
  pPass.IN.Color1 = IN.Color1;
#if %_LT_LIGHTS && %_LT_HASPROJ  
  pPass.IN.projTC = IN.projTC;
#endif    

  pPass.IN.AvgFogVolumeContrib = half4(0,0,0,1);

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_begin(inout fragPass pPass)
{
  // load the diffuse texture
  half4 baseColor = tex2DTerrain(baseMap_FromContainerSampler, pPass.IN.basesectorTC.xy);
  
	float4 baseTC = pPass.IN.baseTC;

  // load the gloss
  pPass.cGlossMap = 1;
#if %GLOSS_MAP
  pPass.cGlossMap = GetTexture2D(glossMapSampler, baseTC.xy);
#endif


#if %_RT_AMBIENT_OCCLUSION //&& %_RT_OBJ_IDENTITY

  // For terrain shader _RT_AMBIENT_OCCLUSION says that second terrain texture exists and normal map can be read
  // Terrain shaders don't read occlusion info from it directly


  half3 vBaseNorm = float3(tex2D(lmMap_FromContainerSampler, pPass.IN.basesectorTC.xy).zx,0);
  vBaseNorm = (vBaseNorm - 0.5h) * 2.h;
  vBaseNorm.z = sqrt( saturate( 1.h - (vBaseNorm.x * vBaseNorm.x + vBaseNorm.y * vBaseNorm.y) ) );

  pPass.vNormal = lerp(pPass.vNormal, vBaseNorm, saturate(pPass.IN.basesectorTC.w/2000));

#endif

#if XENON 
  #if %_RT_SRGB 
    // On 360 since surface format always srgb and not possible to disable on the fly (at least for now)
    // like in dx10/dx9/ps3,we have to convert back to linear space manually. Might be a good thing to have a RT_SRGB in future  
    baseColor.xyz = sqrt(baseColor.xyz);
  #endif
#endif

  // restore original range
  baseColor.xyz *= BaseTCMatrix[3];

#if !%_RT_OBJ_IDENTITY
	// color can come from vertex in case of voxels
	baseColor.rgb = lerp(baseColor.rgb, pPass.IN.Color1.rgb, pPass.IN.Color1.a); 
#endif

  // material color is offseted from base
  pPass.cDiffuseMap.xyz = saturate( baseColor.xyz + ((pPass.cDiffuseMap-0.5h) * DetailTextureStrength) );
  
#if XENON || PS3
  #if %_RT_SRGB  
    pPass.cDiffuseMap.xyz *= pPass.cDiffuseMap.xyz;
  #endif
#else
  // Note: for now we don't support %_RT_SRGB on other specs than consoles to limit permutation amount
  
  // final terrain color srgb conversion: we do a lerp bettween srgb and non-srgb to avoid having to add tons of permutations just for this case 
  pPass.cDiffuseMap.xyz *= lerp(1.0h, pPass.cDiffuseMap.xyz, g_PS_SkyColor.w);
#endif
  
  // Output alpha
  half fAlpha = pPass.cDiffuseMap.a;	

	pPass.fAlpha = sqrt( saturate(pPass.IN.Color.g) ) * AmbientOpPB.a; // sqrt is needed to avoid seams between layers
	pPass.pCustom.fDiffuseAlpha = fAlpha * pPass.fAlpha;	
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Lighting
void frag_custom_per_light(inout fragPass pPass, inout fragLightPass pLight)
{
  pLight.fNdotL = saturate(pLight.fNdotL);
  
  half3 cDiffuse = 0;

  cDiffuse = pLight.cDiffuse.xyz * pLight.fNdotL;                    // 2 alu
  
  half fSpec = 0;      
  half fPow = pPass.fSpecPow;
 #if %SPECULARPOW_GLOSSALPHA
  fPow *= pPass.cGlossMap.a;
 #endif
  fSpec = Phong(pPass.vNormal.xyz, pPass.vView.xyz, pLight.vLight.xyz, fPow);
 #if %GLOSS_DIFFUSEALPHA
   fSpec *= pPass.pCustom.fDiffuseAlpha;
 #endif

  // Final specular term
  half3 cSpecular = pLight.cSpecular.xyz * fSpec;			                   		// 1 alu
  
  half3 cK = pLight.fOcclShadow * pLight.fFallOff * pLight.cFilter;                                // 2 alu 
      
  // Accumulate results
  pPass.cDiffuseAcc += cDiffuse * cK;

  if( GetShaderQuality() > QUALITY_LOW )
    pPass.cSpecularAcc += cSpecular * cK;  
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_ambient(inout fragPass pPass, inout half3 cAmbient)
{
#if %_RT_AMBIENT  
  cAmbient.xyz = AmbientOpPB.xyz * (pPass.vNormal.z*0.5h+0.5h) * pPass.IN.Color.a;
#else
  cAmbient = 0;
#endif
  
  pPass.cAmbientAcc += cAmbient.xyz;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_end(inout fragPass pPass, inout half3 cFinal)
{
#if !%_RT_AMBIENT
  cFinal *= pPass.fAlpha;
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "fragLib.cfi"

///////////////// terrain pixel shader //////////////////
pixout TerrainPS(vert2fragTerrain IN)
{
  pixout OUT	= (pixout)0;

#if PS3
  #pragma sce-cgc("-texformat default COMPRESSED_RGBA_S3TC_DXT5");  
#endif

  half4 baseColor = tex2DTerrain(baseMapSampler, IN.baseTC.xy);

	// restore original range
  baseColor.rgb = sqrt(baseColor.rgb);
  baseColor.xyz *= BaseTCMatrix[3];
  baseColor.rgb*=baseColor.rgb;
  
  #if !%_RT_OBJ_IDENTITY
	  // color can come from vertex in case of voxels
	  baseColor.rgb = lerp(baseColor.rgb, /*IN.Color1.rgb*/0, IN.Color1.a); 
  #endif

   // Debug output
 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, IN.baseTC);
   return OUT;
 #endif

  half4 shadowOccl = 0;

  if( GetShaderQuality() > QUALITY_LOW )
  {
    shadowOccl = tex2Dproj(shadowOccludeMapSampler, IN.screenProj.xyzw);
  }

	// Used when sun is in use
  half3 terrainNormal;

#if %_RT_AMBIENT_OCCLUSION //&& %_RT_OBJ_IDENTITY
  // For terrain shader _RT_AMBIENT_OCCLUSION says that second terrain texture exists and normal map can be read
  // Terrain shaders don't read occlusion info from it directly
  half3 vNorm = float3(tex2D(lmMapSampler, IN.baseTC.xy).zx,0);
  vNorm = (vNorm - 0.5h) * 2.h;
  vNorm.z = sqrt(saturate(1 - (vNorm.x * vNorm.x + vNorm.y * vNorm.y) ));
  terrainNormal = vNorm;
#else
  terrainNormal = IN.vNormal.xyz;
#endif

	half3 vLighting = DecodeLightBuffer( tex2Dproj( sceneDiffuseAccSampler, IN.screenProj.xyzw) ); 
  half NdotL = saturate(dot(half3(g_PS_SunLightDir.xyz), terrainNormal));
	half3 vColor = baseColor.xyz * (
      g_PS_SunColor.xyz * (1.0h-shadowOccl.x) * NdotL * (baseColor.a*0.6666h+0.3333h) + // sun diffuse TODO: remove it - merge into lbuffer
			vLighting); // deferred lighting

  half fOutA = AmbientOpPB.a * baseColor.a;

#if %_RT_HDR_SYSLUMINANCE    
  vColor.xyz *= g_PS_FogColor.w;
#endif

  ComputeGlobalFogPS(vColor.xyz, IN.vNormal.w);

  half4 cOutColor = half4(vColor.xyz, 1);
#if PS3
  #if %_RT_HDR_MODE
    cOutColor = EncodeHDRBuffer( cOutColor );
  #endif
#endif
  
  // finally add them all together
  HDROutput(OUT, cOutColor, 1); 

  return OUT;
}


pixout TerrainLayerPS(vert2fragLayer IN)
{
  pixout OUT = (pixout)0;
  
  // Initialize fragPass structure
  fragPass pPass = (fragPass) 0;
  frag_unify(pPass, IN);
  pPass.bDontUseEmissive = true;

  // No bump on low-spec - Cevat request -
  int nQuality = GetShaderQuality();
  if (nQuality == QUALITY_LOW)
    pPass.bDontUseBump = true;
    
  half4 cFinal = frag_shared_output(pPass);
  
  HDROutput(OUT, cFinal, 1);

  return OUT;
}

//////////////////////////////// technique ////////////////

technique General
<
  string Script =
        "NoLights;"
        "TechniqueZ=ZPass;"
        "TechniqueShadowGen=ShadowGen;"
        "TechniqueShadowPass=ShadowPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_Auto TerrainVS() TerrainVS;
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;
        
    PixelShader = compile ps_Auto TerrainPS() TerrainPS;
  }
}

technique Layer
<
  string Script = "Public;"
                  "TechniqueZ=ZPass;"
                  "TechniqueCaustics=CausticsPass;"
                  "TechniqueShadowPass=ShadowPass;"
                  "PositionInvariant;";
>
{
  pass p0
  {
    
    ZEnable = true;
    CullMode = Back;

    SrcBlend = SrcAlpha;
    DestBlend = InvSrcAlpha;
  
    AlphaBlendEnable = true;
    ZWriteEnable = false;
    
#if %DYN_BRANCHING || %PARALLAX_OCCLUSION_MAPPING
    VertexShader = compile vs_3_0 TerrainLayerVS() TerrainVS;
    PixelShader = compile ps_3_0 TerrainLayerPS() TerrainPS;
#else
    VertexShader = compile vs_Auto TerrainLayerVS() TerrainVS;
    PixelShader = compile ps_Auto TerrainLayerPS() TerrainPS;
#endif
  }
}

//////////////////////////////// Common techniques ////////////////

#include "CommonZPass.cfi"
#include "CommonCausticsPass.cfi"
#include "ShadowCommon.cfi"
#include "CommonShadowGenPass.cfi"
#include "CommonShadowPass.cfi"

/////////////////////// eof ///
