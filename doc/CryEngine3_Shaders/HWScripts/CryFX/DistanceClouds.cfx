
#include "Common.cfi"
#include "ShadeLib.cfi"
#include "ModificatorVT.cfi"

float Script : STANDARDSGLOBAL
<
	string Script =
		"Public;"
		"Decal;"
		"ShaderDrawType = General;"
        "ShaderType = FX;"
>;

#if !%SIMPLE

float4 CameraRightVector			: PB_CameraRight;
float4 CameraUpVector				: PB_CameraUp;

float3 ShadeColorFromSun			: PB_CloudShadingColorSun;
float3 ShadeColorFromSky			: PB_CloudShadingColorSky;

float Attenuation
<
  psregister = PS_REG_PM_3.x;
	string UIHelp = "Attenuation of light scattered through cloud";
	string UIName = "Attenuation";
	string UIWidget = "slider";
	float UIMin = 0.0;
	float UIMax = 5.0;
	float UIStep = 0.01;
> = 0.6;


float StepSize
<
  psregister = PS_REG_PM_3.y;
	string UIHelp = "Step size through cloud texture";
	string UIName = "StepSize";
	
	string UIWidget = "slider";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.001;
> = 0.004;


float AlphaSaturation
<
  psregister = PS_REG_PM_3.z;
	string UIHelp = "Alpha saturation of cloud texture";
	string UIName = "AlphaSaturation";
		
	string UIWidget = "slider";
	float UIMin = 0.1;
	float UIMax = 10.0;
	float UIStep = 0.1;
> = 2.0;


float SunColorMultiplier
<
  psregister = PS_REG_PM_3.w;
	string UIHelp = "Sun color multiplier";
	string UIName = "SunColorMultiplier";
		
	string UIWidget = "slider";
	float UIMin = 0.0;
	float UIMax = 16.0;
	float UIStep = 0.1;
> = 4.0;


float SkyColorMultiplier
<
  psregister = PS_REG_PM_4.x;
	string UIHelp = "Sky color multiplier";
	string UIName = "SkyColorMultiplier";
		
	string UIWidget = "slider";
	float UIMin = 0.0;
	float UIMax = 16.0;
	float UIStep = 0.1;
> = 1.5;

#else

float Opacity
<
  psregister = PS_REG_PM_3.x;
	string UIHelp = "Opacity modifier for the cloud";
	string UIName = "Opacity";
	string UIWidget = "slider";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
> = 1.0;

#endif


sampler2D diffuseSampler = sampler_state
{
	Texture = $Diffuse;
};

struct a2v
{
	float4 Position	: POSITION;
	float2 baseTC	: TEXCOORD0;
	float4 color	: COLOR0;
	float4 Tangent	: TANGENT;
	float4 Binormal	: BINORMAL;
};


struct v2f
{
	float4 Position		: POSITION;
	float2 baseTC		: TEXCOORD0;
	float3 toSun		: TEXCOORD1;

#if PS3
  #if %_RT_HDR_MODE
    float4 screenProj : TEXCOORD2;
  #endif
#endif
};


struct v2f_simple
{
	float4 Position		: POSITION;
	float2 baseTC		: TEXCOORD0;

#if PS3
  #if %_RT_HDR_MODE
    float4 screenProj : TEXCOORD1;
  #endif
#endif
};


v2f DistanceCloudsVS(a2v IN)
{
	v2f OUT = (v2f)0;

	// Position in screen space
	float4 vPos = IN.Position;
	OUT.Position = mul(vpMatrix, vPos);
	OUT.Position.z = OUT.Position.w;

	
	OUT.baseTC.xy = IN.baseTC.xy;
	
  float3x3 objToTangentSpace;
  objToTangentSpace[0] = IN.Tangent.xyz;
  objToTangentSpace[1] = IN.Binormal.xyz;
  objToTangentSpace[2] = normalize(cross(objToTangentSpace[0], objToTangentSpace[1])) * IN.Tangent.w;

	OUT.toSun = mul( objToTangentSpace, g_VS_SunLightDir.xyz );

#if PS3
  #if %_RT_HDR_MODE
     OUT.screenProj = HPosToScreenTC(OUT.Position);
  #endif
#endif
	
	return OUT; 
}


pixout DistanceCloudsPS(v2f IN)
{
	pixout OUT;
	
   // Debug output
 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, float4(IN.baseTC, 0, 1));
   return OUT;
 #endif
	
	const int c_numSamples = 8;
	
	float3 toSun = normalize( IN.toSun.xyz );
	float2 sampleDir = toSun.xy * StepSize;
	float2 uv = IN.baseTC.xy;
	
	float opacity = tex2D( diffuseSampler, uv ).x;
	float density = 0;
	
	//float height = -opacity;
	//toSun *= 2.0 / (float) c_numSamples;
	
	for( int i = 0; i < c_numSamples; i++ )
	{
		float t = tex2D( diffuseSampler, uv + i * sampleDir ).x;
		density += t /** step( abs( height ), t )*/;
		//height += toSun.z;
	}
	
  // Re-scale range

	float c = exp2( -Attenuation * density );
	float a = pow( opacity, AlphaSaturation );
	float3 col = lerp( SkyColorMultiplier * ShadeColorFromSky.xyz, SunColorMultiplier * ShadeColorFromSun.xyz, c );
  // Re-scale range
  col *= PS_HDR_RANGE_ADAPT_MAX;
	
	half4 Color = half4( col, a );

#if PS3
  #if %_RT_HDR_MODE
    half4 cDstColor = DecodeHDRBuffer( tex2Dproj( HDRTargetEncodedSampler, IN.screenProj) );
    Color = lerp(cDstColor, Color, Color.a);
    Color = EncodeHDRBuffer( Color );
  #endif  
#endif

	HDROutput(OUT, Color, 1);
	
	return OUT;
}


v2f_simple DistanceCloudsSimpleVS(a2v IN)
{
	v2f_simple OUT = (v2f_simple)0;

	// Position in screen space
	float4 vPos = IN.Position;
	OUT.Position = mul(vpMatrix, vPos);
	OUT.Position.z = OUT.Position.w;
	
	OUT.baseTC.xy = IN.baseTC.xy;

#if PS3
  #if %_RT_HDR_MODE
     OUT.screenProj = HPosToScreenTC(OUT.Position);
  #endif
#endif
	
	return OUT; 
}


pixout DistanceCloudsSimplePS(v2f_simple IN)
{
	pixout OUT;
	
   // Debug output
 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, float4(IN.baseTC, 0, 1));
   return OUT;
 #endif

	half4 col = tex2D(diffuseSampler, IN.baseTC.xy);
	OUT.Color = half4(MatDifColor.xyz * col.xyz, col.w * Opacity);

  // Re-scale range
  OUT.Color.rgb *= PS_HDR_RANGE_ADAPT_MAX;

#if PS3
  #if %_RT_HDR_MODE 
    half4 cDstColor = DecodeHDRBuffer( tex2Dproj( HDRTargetEncodedSampler, IN.screenProj) );
    OUT.Color = lerp(cDstColor, OUT.Color, OUT.Color.a);
    OUT.Color = EncodeHDRBuffer( OUT.Color );
  #endif
#endif
	
	return OUT;
}


technique General
{
	pass p0
	{
#if !%SIMPLE
		VertexShader = compile vs_Auto DistanceCloudsVS();
#else
		VertexShader = compile vs_Auto DistanceCloudsSimpleVS();
#endif
		ZEnable = true;
		ZWriteEnable = false;
		CullMode = None;
		
		AlphaBlendEnable = true;
		SrcBlend = SrcAlpha;
		DestBlend = InvSrcAlpha;
#if !%SIMPLE
		PixelShader = compile ps_Auto DistanceCloudsPS();
#else
		PixelShader = compile ps_Auto DistanceCloudsSimplePS();
#endif
	}
}
