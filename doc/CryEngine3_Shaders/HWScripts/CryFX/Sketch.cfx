
#include "Common.cfi"


// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "ShaderDrawType = Light;"
           "ShaderType = General;"
>;

float2 TexelsPerMeterInfo : PB_TexelsPerMeterInfo;

float4x4 LayerTexGen      : PB_TerrainLayerGen;
float4 TexelDensityParam  : PB_TexelDensityParam;
float4 TexelDensityColor  : PB_TexelDensityColor;

sampler2D gradientSampler = sampler_state
{
  Texture = textures/defaults/TexelsPerMeterGrad.tif;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE; 
  AddressU = Clamp;
  AddressV = Clamp;
};

struct fragPassCustom
{ 

#ifdef PS3
	float4 Dummy;
#endif

};

struct fragLightPassCustom
{

#ifdef PS3
	float4 Dummy;
#endif

}; 

#include "ShadeLib.cfi"

// Un-Tweakables /////////////////

ENVIRONMENTMAP
ENVIRONMENTCUBEMAP

//////////////////////////////// Common vertex shader ////////////////

#include "VertexLib.cfi"

///////////////// vertex shader //////////////////
vert2FragGeneral SketchVS(app2vertGeneral IN)
{
  vert2FragGeneral OUT = (vert2FragGeneral)0; 
  
	streamPos vertPassPos = (streamPos)0;
  vs_shared_output( IN, OUT, vertPassPos, false );

  return OUT;
}

///////////////// pixel shader //////////////////

void frag_unify_parameters( inout fragPass pPass )
{
  
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_begin(inout fragPass pPass)
{

  pPass.fAlpha = pPass.cDiffuseMap.w * pPass.IN.Ambient.w;
  pPass.vNormal = pPass.mTangentToWS[2];                                      // 3 alu

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


void frag_custom_per_light(inout fragPass pPass, inout fragLightPass pLight)
{  
	pPass.cDiffuseAcc.xyz += saturate( pLight.fNdotL ) * pLight.cDiffuse.xyz * pLight.fFallOff * pLight.cFilter;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


void frag_custom_ambient(inout fragPass pPass, inout half3 cAmbient)
{

	pPass.cAmbientAcc.xyz += pPass.IN.Ambient.xyz;
  
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_end(inout fragPass pPass, inout half3 cFinal)
{
}


#include "fragLib.cfi"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

pixout SketchPS(vert2FragGeneral IN)
{
	pixout OUT = (pixout) 0;  

  // Initialize fragPass structure
  fragPass pPass = (fragPass) 0;
  frag_unify(pPass, IN);  
  half4 cFinal = frag_shared_output(pPass);
    		  
  HDROutput(OUT, cFinal, 1);

	return OUT;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
struct vert2FragSketchFast
{  
  OUT_P
  float4 baseTC     : TEXCOORDN;
  
  float4 vTangent  : TEXCOORDN;
  float4 vBinormal : TEXCOORDN;
  float4 Ambient    : TEXCOORDN;
  float4 vView     : TEXCOORDN;       
  
#if %_LT_LIGHTS && %_LT_HASPROJ  
  float4 projTC     : TEXCOORDN;
#endif    
};

vert2FragSketchFast SketchFastVS(app2vertGeneral IN)
{
  vert2FragSketchFast OUT = (vert2FragSketchFast)0; 
  
  //vs_shared_output( IN, OUT, false );
  
  streamPos vertPassPos = (streamPos)0;
  streamPos_FromGeneral(IN, vertPassPos);
  
  OUT.HPosition = Pos_VS_General(g_VS_ViewProjZeroMatr, vertPassPos);
  
  _TCModify(vertPassPos.baseTC, OUT.baseTC, 0, 0, TS_DIFFUSE);
  
  // Output world to tangent matrix and world space position  
  // Note: Normalization required for normal diffuse map in world space in case scale used - Do not remove
  float3 worldTangentS = normalize( mul((const float3x3)vertPassPos.InstMatrix, vertPassPos.ObjToTangentSpace[0]) );
  float3 worldTangentT = normalize( mul((const float3x3)vertPassPos.InstMatrix, vertPassPos.ObjToTangentSpace[1]) );
  float3 worldTangentN = (cross(worldTangentS, worldTangentT)) * vertPassPos.Tangent.w;
  
  OUT.vTangent = float4(worldTangentS, vertPassPos.Tangent.w); 
  OUT.vBinormal.xyz = worldTangentT;
  OUT.vView.xyz = vertPassPos.WorldPos.xyz;
  
  // Output ambient color
  OUT.Ambient = AmbientOp;

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void sketch_frag_unify(inout fragPass pPass, in vert2FragSketchFast IN)
{
  pPass.IN.baseTC = IN.baseTC;
  pPass.IN.bumpTC = pPass.IN.baseTC;
  pPass.IN.vTangent = IN.vTangent;
  pPass.IN.vBinormal = IN.vBinormal;
  pPass.IN.vNormal.xyz = (cross(IN.vTangent.xyz, IN.vBinormal.xyz)) * IN.vTangent.w;                  // 4 alu
  pPass.IN.vView = IN.vView;
  //pPass.IN.screenProj = IN.screenProj;

  pPass.IN.Ambient = IN.Ambient;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
half4 sketch_frag_shared_output(inout fragPass pPass)
{ 
  half4 cOut = 0;
  
  float4 baseTC = pPass.IN.baseTC;

  pPass.vView = normalize(-pPass.IN.vView.xyz);                                                           // 3 alu  
  pPass.mTangentToWS = float3x3(pPass.IN.vTangent.xyz, pPass.IN.vBinormal.xyz, pPass.IN.vNormal.xyz);  
      
  pPass.cDiffuseMap = tex2D(diffuseMapSampler, baseTC.xy);  
		    
  // Get main vectors/coeficients	     
  pPass.fAlpha = pPass.cDiffuseMap.w * pPass.IN.Ambient.w;
  pPass.vNormal = pPass.mTangentToWS[2];                                      // 3 alu
  pPass.vNormalDiffuse = pPass.vNormal;

  // Store some constant coeficients
  pPass.fNdotE = ( dot(pPass.vView.xyz, pPass.vNormal.xyz));                                        // 1 alu
  pPass.fSpecPow = MatSpecColor.w;	
  pPass.vReflVec = (2.0 * pPass.fNdotE * pPass.vNormal.xyz) - pPass.vView.xyz;                      // 2 alu

  half3 vAmbientNormal = pPass.vNormalDiffuse.xyz;

#if %_LT_LIGHTS      
  // Light types
  int aLType[4] = {%_LT_0_TYPE, %_LT_1_TYPE, %_LT_2_TYPE, %_LT_3_TYPE};        
  for (int i=0; i<%_LT_NUM; i++)
  {       
    float4 WorldLightPos;

    int nType = aLType[i];
    WorldLightPos = LGetPosition(i);

    half4 Diffuse =  LGetDiffuse(i);

    // Some optimisations for sun light (per-frame parameters and hardcoded values)    
    if (nType == LT_DIRECTIONAL)
    {
      WorldLightPos = g_PS_SunLightDir;
    }
    
    half fFallOff = 1;
    float3 vLight, vLightWS;
    if (nType == LT_DIRECTIONAL)
    {
      vLightWS = WorldLightPos.xyz * 10000.0f;
      vLight = WorldLightPos.xyz;
    }
    else
    {
      vLightWS = WorldLightPos.xyz - pPass.IN.vView.xyz;      
      vLight = normalize(vLightWS.xyz);                                                         // 3 alu
      fFallOff = GetAttenuation(vLightWS.xyz, WorldLightPos.w);                                   // 2 alu
    }
    
    half3 filterColor = 1;
    
    // Compute diffuse
    half fNdotL = dot(vLight.xyz, pPass.vNormal.xyz);                                                   // 1 alu
                       
    { 
      // Initialize light pass structure with per-light shared data
      fragLightPass pLight = (fragLightPass) 0;
      
      pLight.nType = nType;
                  
      pLight.cDiffuse = Diffuse;
      pLight.cSpecular = 0;

      pLight.vLight = vLight;
      
      pLight.fNdotL = fNdotL;
      
      pLight.fFallOff = fFallOff;
      pLight.cFilter = filterColor;
                                                             
      // per shader custom shading 
      pPass.cDiffuseAcc.xyz += saturate( pLight.fNdotL ) * pLight.cDiffuse.xyz * pLight.fFallOff * pLight.cFilter;
    }      
  }
#endif

  half3 amb = pPass.IN.Ambient.xyz;
  pPass.cAmbientAcc.xyz += pPass.IN.Ambient.xyz;
        
  cOut.xyz = ( pPass.cAmbientAcc.xyz + pPass.cDiffuseAcc.xyz ) * pPass.cDiffuseMap.xyz;           // 2 alu  
  
  // distance blend out
  cOut.w = pPass.fAlpha;
    
  return cOut;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
pixout SketchFastPS(vert2FragSketchFast IN)
{
	pixout OUT = (pixout) 0;  

  // Initialize fragPass structure
  fragPass pPass = (fragPass) 0;

  sketch_frag_unify(pPass, IN);  
  half4 cFinal = sketch_frag_shared_output(pPass);
 
  OUT.Color = cFinal;

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
pixout SketchTexelsPerMeterPS(vert2FragSketchFast IN)
{
	pixout OUT = (pixout) 0;  
	
	// sample diffuse tex so texture modificator in VS gets properly applied
	// multiply by very small number and use result so compiler doesn't optimize tex fetch away
	float3 c = tex2D(diffuseMapSampler, IN.baseTC.xy) * 0.0001;

  float3 ddx_P = ddx(IN.vView.xyz);
  float3 ddy_P = ddy(IN.vView.xyz);
  
  float2 ddx_T = ddx(IN.baseTC.xy);
  float2 ddy_T = ddy(IN.baseTC.xy);
  
  float tx = length(ddx_T) / length(ddx_P) * TexelsPerMeterInfo.x;
  float ty = length(ddy_T) / length(ddy_P) * TexelsPerMeterInfo.y;
  
  float t = max(tx, ty);
  
  c += tex2D(gradientSampler, float2(t, 0.25));
  
  float2 p = frac(IN.baseTC.xy * ResInfoDiffuse.xy / 16.0); // 16x16 texels are a 2x2 checkerboard block
  float checker = p.x < 0.5 ? (p.y < 0.5 ? 0.9 : 1) : (p.y < 0.5 ? 1 : 0.9);
  
 	OUT.Color = float4(c * checker, 1);

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
pixout SketchTexelDensityPS(vert2FragSketchFast IN)
{
	pixout OUT = (pixout) 0;  

  float2 p = frac(IN.baseTC.xy * TexelDensityParam.xy / 32.0); // 32x32 texels are a 2x2 checkerboard block
  float color = (p.y < 0.5 ? 1 : 0.0);
  float checker = p.x < 0.5 ? 1-color : color;
  
  OUT.Color.xyz = 0.1*tex2D(diffuseMapSampler, IN.baseTC.xy)+0.9*float3(checker*TexelDensityColor.xyz);
	OUT.Color.w = 1;//IN.Color.g;

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////// technique ////////////////

technique General
<
  string Script = "TechniqueZ=ZPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_Auto SketchFastVS();
    PixelShader = compile ps_Auto SketchFastPS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;       
  }
}

//////////////////////////////// technique ////////////////

technique TexelsPerMeter
<
  string Script = "TechniqueZ=ZPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_3_0 SketchFastVS();
    PixelShader = compile ps_3_0 SketchTexelsPerMeterPS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;       
  }
}

//////////////////////////////// technique ////////////////

technique TexelDensity
<
  string Script = "TechniqueZ=ZPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_3_0 SketchFastVS();
    PixelShader = compile ps_3_0 SketchTexelDensityPS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;       
  }
}

//////////////////////////////// helper techniques ////////////////
technique General1
<
  string Script = "TechniqueZ=ZPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_Auto SketchVS();
    PixelShader = compile ps_Auto SketchPS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;       
  }
}

technique General2
<
  string Script = "TechniqueZ=ZPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_Auto SketchVS();
    PixelShader = compile ps_Auto SketchPS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;       
  }
}

technique Fast
<
  string Script = "TechniqueZ=ZPass;"
>
{
  pass p0
  {
    VertexShader = compile vs_Auto SketchVS();
    PixelShader = compile ps_Auto SketchPS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = Back;       
  }
}

#include "CommonZPass.cfi"

/////////////////////// eof ///
