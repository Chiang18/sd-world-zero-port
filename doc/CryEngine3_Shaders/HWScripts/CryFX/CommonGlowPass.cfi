////////////////////////////////////////////////////////////////////////////
//
//  Crytek Engine Source File.
//  Shader extension
//  Copyright (C), Crytek Studios, 2001-2004.
// -------------------------------------------------------------------------
//  File name:   CommonGlowPass.cfi
//  Version:     v1.00
//  Created:     23/11/2004 by Tiago Sousa
//  Compilers:   
//  Description: Common/Shared passes bettwen shaders. Should be included after
//    main shader technique
//
//  NOTE: ALWAYS MAKE SURE VERTEX INPUTS MATCH CORRECTLY BEFORE INCLUDING THIS!
//  TODO: Add support for texture modifiers, since Illum and others require it
//  "Common_" name convention - for shader sharing in cache files
//
//
// -------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////

/// Un-Tweakables ////////////////////// 
// xyz = glow intensity/color, alpha is glow size

float4 GlowParams : PB_GlowParams;

sampler2D glowDiffuseMapSampler : register (s0) 
{ 
  Texture = $Diffuse; 
  sRGBLookup = false; 
};

sampler2D glowDiffuseMapSampler_Decal
{ 
	Texture = $Diffuse; 	
	AddressU = Border;
	AddressV = Border;
	BorderColor = {0, 0, 0, 0};	
  sRGBLookup = false; 
};

sampler2D glowDecalMapSampler = sampler_state 
{ 
  Texture = $DecalOverlay; 
};

////////////////////////////////////////////////////////
//                Glow PASS
////////////////////////////////////////////////////////

///////////////// vertex input/output //////////////////
struct vert2fragGlow
{
  OUT_P
  float4 baseTC     : TEXCOORDN;
  float4 maskTC     : TEXCOORDN;

#if %_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D
  float3 DistAtten : TEXCOORDN;
#endif  
};

///////////////// vertex shaders //////////////////
vert2fragGlow Common_GlowPassVS(app2vertGlow IN)
{
  vert2fragGlow OUT = (vert2fragGlow)0;
  
  streamPos vertPassPos = (streamPos)0;
  streamPos_FromGlow(IN, vertPassPos);

  OUT.HPosition = Pos_VS_General(g_VS_ViewProjZeroMatr, vertPassPos);
  
  float4 baseTC = vertPassPos.baseTC;
#if %_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D
	_TCModifyDecal( vertPassPos, baseTC, OUT.DistAtten );
#endif

  // reminder for Andrey, texture modifiers should work on all cases
  _TCModify(baseTC, OUT.baseTC, vertPassPos.Position, vertPassPos.ObjToTangentSpace[2], TS_DIFFUSE);

  //OUT.baseTC = _TCModify(baseTC, vPos, vNorm, _TCMMatrixDif, _TCGMatrixDif, true, false, 0);
  OUT.maskTC.xyzw = mul(baseTC, _TCMMatrixDecal);
  
  float fAlphaRef = 0.01;

  OUT.maskTC.z = saturate( fAlphaRef );

  float fAlpha = AmbientOp.w;
#if %_RT_INSTANCING_ATTR
  fAlpha = IN.InstAmbientOp.w;
#endif
  OUT.maskTC.w = fAlpha;

  return OUT;            
}

///////////////// pixel shaders //////////////////
pixout Common_GlowPassPS(vert2fragGlow IN)
{
  pixout OUT = (pixout)0;  

  half4 baseColor = tex2D(glowDiffuseMapSampler, IN.baseTC.xy);
  half4 maskColor = 1;
  
   // Load the diffuse texture
#if ((%DECAL && (%_RT_DECAL_TEXGEN_2D || %_RT_DECAL_TEXGEN_3D)) || %CHARACTER_DECAL)
  #if %_TT0_TCPROJ
    baseColor = tex2Dproj(glowDiffuseMapSampler_Decal, IN.baseTC.xyzw);
  #else
    baseColor = GetTexture2D(glowDiffuseMapSampler_Decal, IN.baseTC.xy);
  #endif
#else

  maskColor = tex2D(glowDecalMapSampler, IN.maskTC.xy);  

#endif

  // todo: better to patch texture header - restore after
#if XENON
  {
    // color srgb conversion: we do a lerp bettween srgb and non-srgb to avoid having to add tons of permutations just for this case 
    half4 baseColorSrgb = sqrt(baseColor);
    baseColor.xyz *= lerp(baseColor.xyz, baseColorSrgb.xyz, g_PS_SkyColor.w);
  }
#endif

  // Apply mask
  baseColor *= maskColor;

  OUT.Color = (half4)GlowParams * baseColor;  
  OUT.Color.xyz *= (half3) MatDifColor;
  OUT.Color.xyz *= baseColor.w * IN.maskTC.w;

#if %_RT_DECAL_TEXGEN_3D
  OUT.Color.xyz *= saturate(1 - IN.DistAtten.x * IN.DistAtten.x) * IN.DistAtten.y;
#elif %_RT_DECAL_TEXGEN_2D
  OUT.Color.xyz *= saturate(1 - dot(IN.DistAtten, IN.DistAtten));
#endif
  
  // Re-scale range
  OUT.Color.xyz *= PS_HDR_RANGE_ADAPT_MAX;
  OUT.Color.w = 1.0;
    
  return OUT;
}

//////////////////////////////// technique ////////////////

technique GlowPass
{
  pass p0
  {
    VertexShader = compile vs_Auto Common_GlowPassVS() GlowVS;
    PixelShader = compile ps_Auto Common_GlowPassPS() GlowPS;

    ZEnable = true;
    ZWriteEnable = false;
    CullMode = Back;
    IgnoreMaterialState = true;

#if %DECAL
    ZFunc = LEqual;    
#endif

    AlphaBlendEnable = true;
    SrcBlend = ONE;
    DestBlend = ONE;        
    ZFunc = LEqual;    

  }
}
