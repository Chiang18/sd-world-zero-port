float4 vfViewPos				: PB_CameraPos;
float4 vfParams					: PB_VolumetricFogParams;
float3 vfFogColor				: PB_VolumetricFogColor;
float4 vfRampParams			: PB_VolumetricFogRampParams;

float3 slHazeColPartialRayleighInScatter : PB_SkyLightHazeColorPartialRayleighInScatter;
float3 slHazeColPartialMieInScatter			 : PB_SkyLightHazeColorPartialMieInScatter;
float3 slSunDirection										 : PB_SkyLightSunDirection;
float3 slPhaseFunctionConstants					 : PB_SkyLightPhaseFunctionConstants;

float4 miscCamFront					: PB_CameraFront;

float3 vfColGradBase		: PB_FogColGradColBase;
float3 vfColGradDelta		: PB_FogColGradColDelta;


half
ComputeVolumetricFog( in float3 cameraToWorldPos )
{
	#define atmosphereScale								vfParams.x
	#define volFogHeightDensityAtViewer 	half(vfParams.y)
	#define fogDensity										half(vfParams.z)
	#define artistTweakDensityOffset			half(vfParams.w)

	half fogInt = 1.h;

	static const float c_slopeThreshold = 0.01f;
	if( abs( cameraToWorldPos.z ) > c_slopeThreshold )
	{
		float t = atmosphereScale * cameraToWorldPos.z;
		fogInt *= ( 1.f - exp( -t ) ) / t;
	}

	// NOTE: volFogHeightDensityAtViewer = log2(e) * fogDensity * exp( -atmosphereScale * ( vfViewPos.z - waterLevel ) );
	half l = length( cameraToWorldPos );
	half u = l * volFogHeightDensityAtViewer;
	fogInt = fogInt * u - artistTweakDensityOffset;

	half f = saturate( exp2( -fogInt ) );
	//return f;

	half r = saturate(l * vfRampParams.x + vfRampParams.y);
	r = r * (2-r);
	//r = smoothstep(0, 1, r);
	r = r * vfRampParams.z + vfRampParams.w;
	f = (1-f) * r;
	return (1-f);
}


//////////////////////////////////////////////////////////////////////////
// Distance based implementation
//////////////////////////////////////////////////////////////////////////


// RET.xyz = fog color (HDR)
// RET.w = fog factor to lerp scene/object color with (i.e. lerp( RET.xyz, sceneColor.xyz, RET.w ) )
half4 
GetVolumetricFogColorDistanceBased( in float3 worldPos, in float3 cameraToWorldPos )
{
	half fog = ComputeVolumetricFog(cameraToWorldPos);
	half l = saturate(normalize(cameraToWorldPos.xyz).z);
	half3 fogColor = vfColGradBase + l * vfColGradDelta;
	return half4(fogColor, fog);
}


half4 
GetVolumetricFogColorDistanceBased( in float3 worldPos )
{
#ifdef %_VS
  vfViewPos.xyz = g_VS_WorldViewPos;
#endif
  float3 camToWorld = worldPos - vfViewPos.xyz;
  return GetVolumetricFogColorDistanceBased( worldPos, camToWorld );
}


//////////////////////////////////////////////////////////////////////////
// Sky light based implementation
//////////////////////////////////////////////////////////////////////////


// RET.xyz = fog color (HDR)
// RET.w = fog factor to lerp scene/object color with (i.e. lerp( RET.xyz, sceneColor.xyz, RET.w ) )
half4 
GetVolumetricFogColorSkyLightBased( in float3 worldPos, in float3 cameraToWorldPos, in float sceneDepth )
{
	half fog = ComputeVolumetricFog( cameraToWorldPos );

	//float g = slPhaseFunctionConstants.x;
	//float g2 = slPhaseFunctionConstants.y;
	//float miePart = slPhaseFunctionConstants.z;
	float miePart_g_2 = slPhaseFunctionConstants.x;  // = pow(miePart, -2/3) * ( -2*g )
	float miePart_g2_1 = slPhaseFunctionConstants.y; // = pow(miePart, -2/3) * ( 1 + g*g )

	half3 skyDir = normalize( cameraToWorldPos );
	half cosine = -dot( slSunDirection, skyDir );
	half cosine2 = cosine * cosine;

	//float miePhase = miePart * ( 1.0 + cosine2 ) / pow( 1.0 + g2 - 2.0 * g * cosine, 1.5 );
	half miePhase = ( 1.h + cosine2 ) * pow( miePart_g2_1 + miePart_g_2 * cosine, -1.5h );

	half rayleighPhase = 0.75h * ( 1.h + cosine2 );

	half3 fogColor = slHazeColPartialMieInScatter * miePhase * saturate( ( sceneDepth - 1 ) * fog ) + slHazeColPartialRayleighInScatter * rayleighPhase;

	fogColor.xyz += vfFogColor.xyz;

#ifndef %_RT_HDR_MODE	
  fogColor.xyz = 1.h - exp( -fogColor.xyz );
#else
  fogColor.xyz = min(fogColor.xyz, (half3) 16384.0);
#endif

  return half4( fogColor.xyz, fog );
}


half4 
GetVolumetricFogColorSkyLightBased( in float3 worldPos )
{
#ifdef %_VS
  vfViewPos.xyz = g_VS_WorldViewPos;
#endif
	float3 camToWorld = worldPos - vfViewPos.xyz;
	float sceneDepth = dot( camToWorld, -miscCamFront.xyz ) * PS_NearFarClipDist.w;
  return GetVolumetricFogColorSkyLightBased( worldPos, camToWorld, sceneDepth );
}


//////////////////////////////////////////////////////////////////////////
// Volumetric fog functions  
// !!! Only call these to get a correct translation    !!!
// !!! based on the currently set rendering conditions !!!
//////////////////////////////////////////////////////////////////////////


half4
GetVolumetricFogColor( in float3 worldPos, in float3 cameraToWorldPos, in float sceneDepth )
{
#if %_RT_SKYLIGHT_BASED_FOG
	return GetVolumetricFogColorSkyLightBased( worldPos, cameraToWorldPos, sceneDepth );
#else
	return GetVolumetricFogColorDistanceBased( worldPos, cameraToWorldPos );
#endif
}


half4
GetVolumetricFogColor( in float3 worldPos )
{
#if %_RT_SKYLIGHT_BASED_FOG
	return GetVolumetricFogColorSkyLightBased( worldPos );
#else
	return GetVolumetricFogColorDistanceBased( worldPos );
#endif
}


half
GetVolumetricFogDensity( in float3 worldPos )
{
#ifdef %_VS
  vfViewPos.xyz = g_VS_WorldViewPos;
#endif
  float3 camToWorld = worldPos - vfViewPos.xyz;
  return ComputeVolumetricFog( camToWorld );
}

void FogFSAA(inout float4 Color, float3 worldPos)
{
#if %_RT_FSAA
  float4 localFogColor = GetVolumetricFogColor(worldPos);
  Color.g = localFogColor.a;
#endif
}

// specif condition for ps3
void FogFSAA(inout half4 Color, float3 worldPos)
{
#if %_RT_FSAA
  half4 localFogColor = GetVolumetricFogColor(worldPos);
  Color.g = localFogColor.a;
#endif
}
