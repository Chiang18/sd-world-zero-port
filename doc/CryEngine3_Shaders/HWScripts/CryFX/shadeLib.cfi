////////////////////////////////////////////////////////////////////////////
//
//  Crytek Engine Source File.
//  Shader extension
//  Copyright (C), Crytek Studios, 2001-2004.
// -------------------------------------------------------------------------
//  File name:   ShadeLib.cfi
//  Version:     v1.00
//  Created:     19/05/2006 by Tiago Sousa
//  Compilers:   
//  Description: Common BRDF's/shading utilities library
//
// -------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////

//==============================================================================
// Dynamic branching support

#if %DYN_BRANCHING && !XENON
  LIGHTINFOMAP
  float4 LightInfoTC_DB : PB_LightInfoTC;
  int LightsNum_DB      : PB_LightsNum;

  #define SHADER_MODEL_VS vs_3_0
  #define SHADER_MODEL_PS ps_3_0
#else
 #define SHADER_MODEL_VS vs_Auto
 #define SHADER_MODEL_PS ps_Auto
#endif

// Common Samplers //////////////////////

DIFFUSEMAP
BUMPMAP
BUMPDIFFUSEMAP 
BUMPHEIGHTMAP
SHADOWOCCLUDEMAP
PROJECTIONMAP
PROJECTIONCUBE
GLOSSMAP 
SCENEDEPTHMAP_POM
AMBIENTOCCLUSIONMAP

sampler2D diffuseMapSampler_Decal
{ 
	Texture = $Diffuse; 	
	AddressU = Border;
	AddressV = Border;
	BorderColor = {0, 0, 0, 0};	
  sRGBLookup = true; 
};

sampler2D detailMapSampler = sampler_state
{
  Texture = $Detail;
};

// Deferred Shading Samplers /////////////

SCENE_NORMALS_MAP
SCENE_DIFFUSEACC_MAP
SCENE_SPECULARACC_MAP
SCENE_HDRTARGET_ENCODED_MAP

////////////////////////////////////////////////////////////////////////////////////////////////////

#define REFLECT_OFF    0
#define REFLECT_CUBE   1
#define REFLECT_SPHERE 2

//////////////////////////////// Shared fragment-shading pass structure /////////////////////////////////////

struct fragInput
{
  //===============================================================================
  // input attribute data
  float4 baseTC;
  float4 basesectorTC;
  float4 bumpTC;
  float4 terrainDetailTC;
  
  half4 vTangent;
  half4 vBinormal;
  half4 vNormal;
  half4 vView;
  
  float4 screenProj;
  float4 projTC;
  
  half4 Color;
  half4 Color1;
  float4 VisTerrainCol;
  float4 SunRefl;
  half4 Ambient;

  half4 AlphaTest;
  
  float3 DistAtten;
  float4 AvgFogVolumeContrib;
  
  float4 OutdoorAOInfo;
};

struct fragPass
{
  fragInput IN;

  // Usage flags fo shared stuff  
  bool bCustomComposition;      // dont use shared final shading composition
  bool bRenormalizeNormal;
	bool bForceRenormalizeNormal;
  bool bDontUseBump;
  bool bDiffuseBump;
  bool bDetailBumpMapping;
  bool bDetailBumpMappingMasking;
  bool bOffsetBumpMapping;
  bool bParallaxOcclusionMapping;  
  bool bVertexColors;      // apply vertex color to final result
  bool bAlphaGlow;         // use diffuse texture alpha has glow
  bool bHemisphereLighting;
  bool bDontUseEmissive;
  bool bRefractionMap; 
  bool bTerrainPass;  
  bool bDisableInShadowShading;  
  bool bDisableAlphaTestD3D10; 
  bool bDeferredSpecularShading;
  bool bSkipMaterial;
  int  nReflectionMapping; // reflection mapping type (0: off, 1: cube map, 2: spherical)
  half fBumpHeightScale;
  half fSelfShadowStrength;
  
  half2 vDetailBumpTilling; // detail diffuse_bump mapping tilling
  half fDetailBlendAmount;	// detail blend amount
  half fDetailBumpScale; 	 // detail bump mapping scale
  
  half fLod;		 					 // lod scale: 1 max, 0 disabled
  
  // shared fields
  int nQuality;           // shader quality level
  
  half3x3 mTangentToWS;  // tangent to world space transformation matrix - might be required for some vectors
  half3 vView;           // eye vector, fFogFrac
  half3 vNormal;         // normal vector
  half3 vNormalDiffuse;  // diffuse normal vector
  half3 vReflVec;        // reflection vector
          
  half3 cBumpMap;        // tangent space normal map
  half4 cDiffuseMap;     // diffuse map
  half4 cGlossMap;       // specular/gloss map
  half3 cEnvironment;    // environment map
  half4 cShadowOcclMap;  // shadow map

  half fNdotE;           // per pass constant NdotE
  half fSpecPow;         // specular power
  half fAlpha;           // opacity   
  half fAlphaTestRef;    // instanced alpha test value
  half cAOMapVal;        // value from AO target

  // deferred rendering RTs
  half4 cNormalMapRT;    // normal maps render target
  half4 cDiffuseAccRT;   // diffuse accumulation render target
  half4 cSpecularAccRT;   // specular accumulation render target
      
  // Note: parser bug, assumes fReflectionAmount, fFresnelBias, etc, are same as tweakable parameters, therefore the _ was added
  
  half fReflection_Amount;  // amount of reflection  
  half fFresnel_Bias;     // fresnel biasing
  half fFresnel_Scale;    // fresnel scale
  half fFresnel;         // final fresnel term
  
  half fAlphaGlow_Multiplier;   // apply multiplier to diffuse alpha glow 
  
  // Shading accumulation
  
  half3 cAmbientAcc;
  half3 cDiffuseAcc;
  half3 cSpecularAcc;

  // Custom per pass data   
  fragPassCustom pCustom;
};
  
struct fragLightPass
{
  int nType;          // light type
  half3 cDiffuse;    // light diffuse color
  half3 cSpecular;   // light specular color
  half3 cFilter;     // light filter color
  half3 vLight;      // light vector
    
  half fNdotL;       // normal dot light
  half fFallOff;     // light attenuation  
  half fOcclShadow;  // light shadow term
  
  half3 cOut;        // light final contribution  

  // ... Custom per light data ...
  fragLightPassCustom pCustom;
}; 


//////////////////////////////// Common shading utilities ////////////////

#define PI 3.1415
#define PI_X2 6.2831
#define PI_X4 12.5663
#define NEPPER 2.7183

half3 ModifyAmbient(half3 ambient, half bumpZ, half bias)
{
  return (ambient * ( saturate( bumpZ ) + bias ) );
}

// assumes 0 is min
half smoothstep_opt(in half maxi, in half x)
{
  x = saturate( x / maxi );
  return  x * x  * (3.0 - 2.0 * x);
}

half GetLuminance( half3 color )
{
	return dot( color, half3( 0.2126h, 0.7152h, 0.0722h ) );
}

half GetFresnel(half NdotI, half bias, half power)
{
  half facing = (1.0 - NdotI);
  return saturate(bias + (1-bias)*pow(facing, power));
}

half GetFresnelOpt(half NdotI, half bias, half power)
{
  half facing = (1.0 - NdotI);
  return bias + pow(facing, power);  // opt: removed (1-bias) mul
}

sampler2D fresnelShlickMapSampler = sampler_state
{
  Texture = textures/defaults/fresnel_sampler.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

// Cheap shlick fresnel term using lookup table (each channel has a diferent power (x = 1,  y = 2, z = 4, w = 5) )
half4 GetFresnelTex( float NdotI, float bias)
{

#if D3D10
  return tex2Dlod( fresnelShlickMapSampler, float4(NdotI, bias, 0, 0) );
#else
  return tex2D( fresnelShlickMapSampler, float2(NdotI, bias) );
#endif

}

half GetRim( in half NdotL, in half NdotH, in half fresnel, in half power, in half multiplier)
{    
  half kr = smoothstep_opt(0.5, fresnel) * multiplier;
  return kr * NdotL * pow(NdotH, power);
} 

half GetRimTex( in half NdotL, in half NdotH, in half fresnel, in half power, in half multiplier)
{        
  half kr = smoothstep_opt(0.5, fresnel) * multiplier;
  return kr * NdotL * pow(NdotH, power);  
  // 4 ALU and 1 TEX
} 

half GetAttenuation(half3 L, half fInvRadius)
{
  half3 vDist = L * fInvRadius;
  half fFallOff = saturate(1-dot(vDist, vDist));

  return fFallOff;
}

half3 NormalToWorldSpace(half3 N, half3x3 mMatrix)
{
  half3 wsN = mul(N, mMatrix);
  wsN = normalize(wsN);
  return wsN;
}

half3 ShiftVector(half3 V, half3 N, half shiftAmount)
{
  return normalize(V + shiftAmount * N);
  // 3 alu, 1 mad
}

// optimized shift vector - skips normalization - use only when vector lenght not relevant
half3 ShiftVectorOpt(half3 V, half3 N, half shiftAmount)
{
  return (V + shiftAmount * N);
  // 1 mad
}

// dot unnormalized vectors 
//  - beware that only in some cases this technique might be a win
half dot_opt(half3 A, half3 B)
{
  // compiler should optimize redundant/repeated computations away
  half AdotA = dot(A, A);                                                                          // 1 dot
  half BdotB = dot(B, B);                                                                          // 1 dot
  
  return dot(A, B) * rsqrt( AdotA * BdotB );                                                        // 1 dot, 3 alu
  
  // 4 alu average 
}

// assumes base in 0..1 range
float pow_schlick( float a, float exponent)
{
  return (1.0 / exponent) * (a - 1.0) + 1.0;    
}

#ifdef PS3
//on PS3 pow is expanded to exp(y*ln(X))
//ln(0) is NAN which will propagate to black pixels on the screen
//the workaround is to use pow_safe, but consider other ways to
//solve that issue as pow_safe cost you one additional instruction
float pow_safe(float x,float y)
{
	return pow(max(x,0.0001f),y);
}

half pow_safe(half x,half y)
{
	return pow(max(x,0.0001f),y);
}
#else
#define pow_safe pow
#endif

//////////////////////////////// Color/blending processing ////////////////////////////////

// Adjust color contrast
half3 ColorContrast( half3 cColor, half fAmount)
{
   //return max( (0.5 - 0.5 * fAmount) + cColor * fAmount, 0.0);                                        // 2 alu
   return max( lerp(0.5, cColor, fAmount), 0.0 );                                        // 2 alu
}

// Adjusts color saturation
half3 ColorSaturation( half3 cColor, half fAmount)
{
   return lerp( GetLuminance(cColor), cColor, fAmount);                                          // should be 2 alu
}

// Adjusts color brightness
half3 ColorBrightness( half3 cColor, half fAmount)
{
   return cColor * fAmount;                                                                         // 1 alu
}

float4 BlendDarken( float4 c1, float4 c2)
{
  return (c1 <  c2)? c1 : c2;					                                          // 1 alu
}

float4 BlendDiference( float4 c1, float4 c2)
{
  return abs(c1 -  c2);													                                          // 2 alu
}

float4 BlendScreen( float4 c1, float4 c2)
{
  return c1 +  c2 * ( 1.0 - c1);													                            // 2 alu
}

float4 BlendOverlay( float4 c1, float4 c2)
{
  return (c1 < 0.5f)? 2.0 * c1 * c2 : -1.0 + 2.0 * BlendScreen(c1, c2);	  // 5 alu
}

//////////////////////////////// Common HDR encoding/decoding ////////////////////////////////

#define MAX_FLOAT						128.h

#define fHDR_EXP_BASE_1_04	1.04h
#define fHDR_EXP_BASE_1_06	1.06h
#define fHDR_EXP_OFFSET			128.h

// Using PPP format
// quality: bad with big maximum
half4 EncodePPP( half4 cColor )
{  
  half fInvMax = 1.h / MAX_FLOAT;  
  return half4(pow( cColor.xyz * fInvMax,  0.25h ), 1.h);
}
 
half3 DecodePPP( in half4 cColor )
{  
  float fInvPowFactor = 1.h / 0.25h;   
  return MAX_FLOAT * pow(cColor.xyz, fInvPowFactor);
}

// Using EEE format (similar to rgbe, but in rgb instead)
// quality: good (although some visible banding), filtering doable
half4 EncodeEEE( in half4 cColor )
{  
  half3 cExp = log(cColor.xyz) / log(fHDR_EXP_BASE_1_04);
  return half4((cExp + fHDR_EXP_OFFSET) / 255.h, 1.h);
}

// Using EEE format (similar to rgbe, but in rgb instead)
// quality: good (although some visible banding), filtering doable 
half4 DecodeEEE( in half4 cColor )
{  
  half3 cExp = cColor.xyz * 255.h - fHDR_EXP_OFFSET;
  return half4( pow(fHDR_EXP_BASE_1_04, cExp), 1.h );
}

// Using RGBS + PPP(scale value stored in alpha - filtering should decode first) 
// quality: very good
half4 EncodeRGBS( in half4 cColor )
{  
  half fInvMaxValue = 1.h / MAX_FLOAT;

  //cColor.xyz = min(cColor.xyz, MAX_FLOAT);

  // remove fractional part (to avoid artefacts) 
  half fMax = ceil(( max(cColor.x, max( cColor.y, cColor.z ) ) ));
  
  half4 ret;    
  ret.xyz = (cColor.xyz / (fMax));    
  ret.w = fMax * fInvMaxValue;  
  
  //ret.w *= rsqrt( ret.w );        
  //ret.xyz *= ret.w;
  
  ret.xyz *= rsqrt( ret );

  return (ret);
}

// Using RGBS format (scale value stored in alpha)
// quality: very good
half4 DecodeRGBS( in half4 cColor )
{     
  return half4( MAX_FLOAT * cColor.xyz * cColor.w * cColor.xyz, 1.h) ;  
}

// Using RGBE format (exponent in alpha- filtering should decode first)
// quality: perfect
half4 EncodeRGBE( in half3 color )
{
  //half fLen = dot(color.xyz, 1.0);  
  half fLen = max( color.x, max( color.y, color.z ) ) ;  
  //half fExp = ( log(fLen) / log(fHDR_EXP_BASE_1_06) );
  half fExp = ceil( log(fLen) / log(fHDR_EXP_BASE_1_06) );

  half4 ret;
  ret.w = (fExp + fHDR_EXP_OFFSET) / 256.h;
  ret.xyz = color.xyz / pow( fHDR_EXP_BASE_1_06, fExp);

  return ret;   
}

// Using RGBE format (exponent in alpha- filtering should decode first)
// quality: perfect
half4 DecodeRGBE( in half4 rgbe )
{ 
  half fExp = rgbe.w * 256.h - fHDR_EXP_OFFSET;
  half fScale = pow(fHDR_EXP_BASE_1_06, fExp);

  return half4( rgbe.xyz * fScale, 1.h);  
}

// Using RGBE format (exponent in alpha - filtering should decode first)
// quality: perfect
half4 EncodeRGBECorrected( in half3 color )
{  
  half fMaxChannel = max( color.x, max( color.y, color.z ) ) ;    
  half fExp = ceil( log2( fMaxChannel ) );
  
  half4 ret = 0.h;
  ret.xyz = color.xyz / exp2( fExp );  
  ret.w = ( fExp + 128.h ) / 256.h;
  
  return ret;
}

// Using RGBE format (exponent in alpha - filtering should decode first)
// quality: perfect
half4 DecodeRGBECorrected( in half4 rgbe )
{   
  return half4( rgbe.xyz * exp2( rgbe.w * 256.h - 128.h), 1.h );
}

void HDREncode(inout half4 Color, out half4 Color1)
{
  half4 origColor = Color;

  Color.xyz /= HDR_FAKE_MAXOVERBRIGHT;
  Color.xyz = floor(Color.xyz * 255.h) / 255.h;
  Color1.xyz = origColor.xyz - Color.xyz*HDR_FAKE_MAXOVERBRIGHT;
  Color1.a = Color.a;
}
// Using RGBK format (multiplier in alpha - filtering should work fine)
// quality: good
half4 EncodeRGBK(in half4 Color, const half fMultiplier)
{
	half alphaStep = 1.h / 255.h * fMultiplier;				// calculate quantization precision
  half fMax = dot(Color.rgb, 1.h);
	fMax = ceil(fMax / alphaStep) * alphaStep;				// stick it to alpha step to avoid quantization artifacts
  Color.xyz /= fMax;
  Color.a = fMax / fMultiplier;
  return Color;
}

half4 DecodeRGBK(in half4 Color, const half fMultiplier)
{
  Color.rgb *= Color.a * fMultiplier;
  return Color;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// These functions are used for each and every manipulation with compressed HDR buffer 
// Currently used only on PS3 because of RT readback possibility

#define SCENE_HDR_MULTIPLIER 32.h

half4 EncodeHDRBuffer( in half4 color )
{
#if PS3
	return EncodeRGBK(color, SCENE_HDR_MULTIPLIER);
#else
	return color;
#endif
}

half4 DecodeHDRBuffer( in half4 rgbk )
{
#if PS3
	return DecodeRGBK(rgbk, SCENE_HDR_MULTIPLIER);
#else
	return rgbk;
#endif
}

half4 EncodeLightBuffer( in half4 color )
{
#if PS3
	return EncodeRGBK(color, SCENE_HDR_MULTIPLIER);
#else
	return color;
#endif
}

half4 DecodeLightBuffer( in half4 color )
{
#if PS3
	return DecodeRGBK(color, SCENE_HDR_MULTIPLIER);
#else
	return color;
#endif
}

//////////////////////////////// SRGB(2.0)/Linear conversion ///////////////////////////////////////
// Handy srgb conversion utilities - beware that filtering will not be 100% correct for texture read
// Tex reads/color writes with condition flag support - helpfull for enabling disabling on the fly

half4 SRGBtoLinear( in half4 cSRGB )
{
  return cSRGB * cSRGB; // srgb -> linear
}

half4 LinearToSRGB( in half4 cLinear )
{
  return sqrt( cLinear ); // linear -> srgb
}

// tex2D override, with srgb read support
half4 tex2Dsrgb( sampler2D smp, float2 tc, bool bSRGBRead )
{
  half4 ret = tex2D(smp, tc);
  if( bSRGBRead )
    ret = SRGBtoLinear( ret );

  return ret;
}

// Output color with srgb write support
half4 SRGBOutput( in half4 color, bool bSRGBWrite )
{
  half4 ret = color;
  if( bSRGBWrite )
    ret = LinearToSRGB( ret );

  return ret;
}

///////////////////////////////// RGB-XYZ space conversion /////////////////////////////////////////

half3 RGBtoXYZ( in half3 cRGB )
{
	const half3x3 RGB_XYZ = 
	{
		half3(0.4125, 0.3576, 0.1805), 
		half3(0.2126, 0.7152, 0.0722),
		half3(0.0193, 0.1192, 0.9505)
	};

	half3 cXYZ = mul(RGB_XYZ, cRGB); 

	// XYZ into to Yxy
	half3 Yxy; 
	Yxy.r = cXYZ.g;  
	Yxy.gb = cXYZ.rg / ( dot(1.h, cXYZ) );

	return Yxy;
}

half3 XYZtoRGB( in half3 Yxy )
{
	const half3x3 XYZ_RGB = 
	{
		half3(3.2410, -1.5374, -0.4986), 
		half3(-0.9692, 1.8760, 0.0416),
		half3(0.0556, -0.2040, 1.0570)
	};

	half3 cXYZ = 0;

	// Put back into XYZ
	cXYZ.rgb = half3( Yxy.g * (Yxy.r / Yxy. b), 
										Yxy.r,
									 (1 - Yxy.g - Yxy.b) * (Yxy.r / Yxy.b) );

	// XYZ into RGB
	half3 cRGB = mul(XYZ_RGB, cXYZ); 

	return cRGB;
}

//////////////////////////////// Common Brdfs ////////////////////////////////
// Note that functions with Tex suffix use optimized code with texture lookups 
// else functions use pure math.

//////////////////////////////// Blinn model ///////////////////////////////
// - Blinn has good properties for plastic and some metallic surfaces. 
// - Good for general use. Very cheap.

half Blinn(half3 N, half3 V, half3 L, half Exp)
{ 
  half3 H = normalize( V + L );				// 4 alu
  return pow( saturate( dot(N, H) ) ,  Exp);	// 4 alu
  
  // 8 ALU
}

//////////////////////////////// Anisotropic blinn model ///////////////////////////////
// - Blinn anisotropic model has good properties for generic anisotropic highlights 
// (can have radial or disk shape)
// - Very cheap

half BlinnAnisotropic(half3 T, half3 B, half3 N, half3 V, half3 L, half2 vSurfaceRoughness, half Exp)
{   
  half3 H = ( V + L ) * 0.5;				                                                                // 2 alu
  half2 HdotT_B = half2( dot(H, B), dot(H, T) ) * vSurfaceRoughness.xy;                           // 3 alu
    
  //return pow( sqrt(saturate( 1 - HdotT_B.x * HdotT_B.x - HdotT_B.y * HdotT_B.y) ), Exp);            // 4 alu + 3 alu  
  
  // merged sqrt with pow -> sqrt<=> pow( scalar, 0.5)  -> pow(sqrt(scalar), exp) <=> pow(scalar, exp * 0.5 )

  return pow( saturate( 1 - dot(HdotT_B.xy, HdotT_B.xy) ), 0.5 * Exp);            // 4 alu
  
  // about 12 ALU
}

sampler2D blinnAnisotropicSampler = sampler_state
{
  Texture = textures/defaults/blinn_anisotropic_sampler.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

half BlinnAnisotropicTex(half3 T, half3 B, half3 N, half3 V, half3 L, half2 vSurfaceRoughness, half Exp)
{   
  half3 H = ( V + L ) * 0.5;				                                                                // 2 alu
  float2 HdotT_B = float2( dot(H, B), dot(H, T) ) * vSurfaceRoughness.xy;                           // 3 alu
  
  const float4 cDecompressD = float4(1.0, 1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * 32.0;
  float fAnisoDistribution = dot( tex2D( blinnAnisotropicSampler, HdotT_B * 0.5 + 0.5).xyzw, cDecompressD.xyzw ); // 1 texl, 1 alu
    
  return pow( fAnisoDistribution, Exp);                         // 3 alu  
  
  // about 9 ALU
}

//////////////////////////////// Phong model /////////////////////////////////////
// - Phong model has good properties for plastic and some metallic surfaces. 
// - Good for general use. Very cheap.

#define ONE_OVER_TWO_PI 0.159155h

// Optimized phong, use if mirrowed reflection vector pre-computed
half Phong(half3 R, half3 L, half Exp)
{	
	half fNormFactor = Exp * ONE_OVER_TWO_PI + ONE_OVER_TWO_PI;		// 1 ALU
  return fNormFactor *  pow(saturate(dot(L, R)), Exp);					// 4 ALU
	// 5 ALU
}

half Phong(half3 N, half3 V, half3 L, half Exp)
{
  half3 R = reflect(-V, N);					// 3 ALU
  return Phong(R, L, Exp);	// 5 ALU
  // 8 ALU
}

//////////////////////////////// Cook-Torrance model ////////////////////////
// - Cook-Torrance model has very good properties for metallic surfaces
// - Pure math versions are expensive.

// Pre-computed cook-torrance D term using a FP32 texture

// todo: use FP16 instead (needs loading support also..)
sampler2D cookTorranceDSampler = sampler_state
{ 
  Texture = shaders/engineassets/shading/cook_d_sampler_g16r16f.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

half GetBeckchamDistribution(half NdotH, half m)
{
  // Compute Beckcham distribution function (D term)
  half  NdotH_pow2 = NdotH * NdotH;                                                              // 1 mul
  half  m2_mul_NdotH_pow2 = m * m * NdotH_pow2;                                                  // 2 alu
  half  tanDelta = ( 1.0 - NdotH_pow2 ) / ( m2_mul_NdotH_pow2 );                                 // 2 alu
  return exp( -tanDelta ) / ( m2_mul_NdotH_pow2 * NdotH_pow2  + 0.001);	                        // 3 alu
  // 8 ALU
}

float GetBeckchamDistributionTex(float NdotH, float m)
{
#if D3D10
  return tex2Dlod( cookTorranceDSampler, float4(NdotH, m, 0, 0) ).x;
#else
  return tex2D( cookTorranceDSampler, float2(NdotH, m) ).x;
#endif
}

half CookTorrance(half3 N, half3 V, half3 L, half fFresnelBias, half m)
{
  // Compute half vector and coeficients
  half3 H = normalize( V + L );								    							    // 1 add, 1 nrm	
  half NdotL = dot( N, L );																		// 1 dot			
  half VdotH = dot( V, H );																		// 1 dot
  half NdotE = dot( N, V );																		// 1 dot	
  half NdotH = dot( N, H );								    									// 1 dot
  half fFresnel = GetFresnelTex(NdotE, fFresnelBias).w;											// 1 texl

  // Compute Beckcham distribution function (D term)
  half  D = GetBeckchamDistribution(NdotH, m);
  
  // Compute geometric attenuation (G term)
  float NdotH_div_VdotH = 2 * NdotH / saturate(VdotH);												// 1 mul, 1 div    
  float G = saturate( min( NdotH_div_VdotH * NdotE, NdotH_div_VdotH * NdotL) ) ;					// 1 mins, 1 mul  

  // Cook-torrance specular term
  return D * G * fFresnel/ (PI * NdotL * (NdotE + 0.01));											// 1 div, 5 muls			
  
  // aprox 26 ALU, 1 TEX
}

// Cheaper version, with pre-computed NdotE and NdotL term. Assuming Fresnel and PI*NdotL term constant 1.0

half CookTorrance(half3 N, half3 V, half3 L, half NdotE, half NdotL, half m)
{
  // Compute half vector and coeficients
  half3 H = normalize( V + L );								    							    // 1 add, 1 nrm	
  half VdotH= dot( V, H );																		// 1 dot	
  half NdotH = dot(N, H);								    									// 1 dot
  
  // Compute Beckcham distribution function (D term)
  half  D = GetBeckchamDistribution(NdotH, m);    
  // Compute geometric attenuation (G term)
  half NdotH_div_VdotH = 2 * NdotH / saturate(VdotH);												// 1 mul, 1 div    
  float G = saturate( min( NdotH_div_VdotH * NdotE, NdotH_div_VdotH * NdotL) ) ;					// 1 mins, 1 mul  

  // Cook-torrance specular term
  return D * G  / (NdotE + 0.01);																			// 1 div, 1 mul
  
  // aprox 18 ALU
}

half CookTorranceTex(half3 N, half3 V, half3 L, half NdotL, float m)
{			
  // Compute half vector and coeficients

  half3 H = normalize( V + L );																	// 1 add, 1 nrm	
  half VdotH = dot( V, H );																		// 1 dot	
  half NdotE = dot( N, V );																		// 1 dot	
  float NdotH = dot( N, H );															    		// 1 dot
    
  // Compute Beckcham distribution function (D term)
  float D = GetBeckchamDistributionTex(NdotH, m);
  
  // Compute geometric attenuation (G term)
  half NdotH_div_VdotH = 2 * NdotH / saturate(VdotH);												// 1 mul, 1 div    
  half G = saturate( min( NdotH_div_VdotH * NdotE, NdotH_div_VdotH * NdotL) ) ;                  // 1 mins, 1 mul  

  return D * G / (NdotE + 0.01);
  
  // aprox 12 ALU, 1 TEX
}

// A bit optimized version, with pre-computed NdotE for all lights and NdotL

half CookTorranceTex(half3 N, half3 V, half3 L, half NdotE, half NdotL, half m)
{
  // Compute half vector and coeficients	

  half3 H = normalize( V + L );																	// 4 alu
  half VdotH = dot( V, H );																		// 1 dot
  half NdotH = dot( N, H );																		// 1 dot

  // Compute Beckcham distribution function (D term)
  half D = GetBeckchamDistributionTex(NdotH, m);    // 1 alu
  
  // Compute geometric attenuation (G term)																									
  half NdotH_div_VdotH = 2 * NdotH / VdotH;/// max(VdotH, 0.01);												// 2 alu
  half G =  saturate( NdotH_div_VdotH *min( NdotE, NdotL) ) ;					// 2 alu

    // assume NdotE and Fresnel = 1
  return D * G/ max(NdotE, 0.001);  // 4

  // aprox 15 ALU
}

//////////////////////////////// Ward model, anisotropic /////////////////////////
// - Ward anisotropic model has good properties for generic anisotropic highlights 
// (can have radial or disk shape)
// - Pure math versions are expensive

half WardAnisotropic(half3 T, half3 B, half3 N, half3 V, half3 L, half2 vSurfaceRoughness, half Exp)
{
  half3 H = normalize( V + L );																	                                  // 1 add, 1 nrm	- 4 alu sum
  half NdotL = saturate( dot( N, L ) );															// 1 dot	
  half NdotE = saturate( dot( N, V ) );															// 1 dot
  half NdotH = dot( N, H );																		// 1 dot

                                    
  half2 HdotT_B = half2( dot( H, B ), dot( H, T ) ) / vSurfaceRoughness.xy;						// 2 dots, 1 div
  HdotT_B *= HdotT_B;																				// 1 mul

  half specK = saturate( rsqrt( NdotL * NdotE ) );													                        //  1 rcp, 1 mul
  specK *= NdotL * exp((-2.0 * (HdotT_B.x + HdotT_B.y))/(1.0 + NdotH));							// 7 alu
             
  return pow(specK, Exp);																			// 1 pow - 3 alu

  // aprox 23 ALU
}

// A bit cheaper version with NdotL and NdotE pre-computed

half WardAnisotropic(half3 T, half3 B, half3 N, half3 V, half3 L, half NdotL, half NdotE, half2 vSurfaceRoughness, half Exp)
{
  half3 H = normalize( V + L );																	                                  // 1 add, 1 nrm	 - 4 alu sum
  half NdotH = dot( N, H ) ;																		                                    // 1 dot	
                                        
  half2 HdotT_B = half2( dot( H, B ), dot( H, T ) ) / vSurfaceRoughness.xy;						            // 2 dots, 1 div
  HdotT_B *= HdotT_B;																				                                        // 1 mul

  // using sat instead, since it's free, but compensating by brighting specular
  half specK = saturate( rsqrt( NdotL * NdotE ) );												                          // 1 rcp, 1 div
  specK *= NdotL * exp((-2.0 * (HdotT_B.x + HdotT_B.y))/(1.0 + NdotH));							                // 7 alu
             
  return pow(specK, Exp);																			                                      // 1 pow - 3 alu

  // aprox 21 ALU
}

sampler2D anisExpSampler = sampler_state
{ 
  Texture = textures/defaults/anis_exp_sampler.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

half GetAnisoDistributionTex(half NdotVec, half s)
{
  const float4 cDecompressD = float4(1.0, 1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * 32.0;	
#if D3D10
  return dot( tex2Dlod( anisExpSampler, float4(NdotVec, s, 0, 0) ), cDecompressD );	
#else
  return dot( tex2D( anisExpSampler, float2(NdotVec, s) ), cDecompressD );	
#endif
  // 1 tex, 1 dot
}

// Note: Assumes surface roughness divided by 10.0 - for a bit extra precision on texture lookup
half WardAnisotropicTex(half3 T, half3 B, half3 N, half3 V, half3 L, half NdotL, half NdotE, half2 vSurfaceRoughness, half Exp)
{
  // opt: averaging vectors instead of normalization
  half3 H = 0.5 *( V + L );																	                                      // 1 add, 1 mul
  
  half NdotH = dot( N, H );	  									                                                  // 1 dot
                                        
  float2 HdotT_B = (abs( half2( dot( H, B ), dot( H, T ) ) *( vSurfaceRoughness.xy)));               // 2 dots, 1 div, 1 abs
  half2 vExpDist;
  vExpDist.x = GetAnisoDistributionTex( HdotT_B.x, NdotH );                                         // 1 tex, 1 dot
  vExpDist.y = GetAnisoDistributionTex( HdotT_B.y, NdotH );                                         // 1 tex, 1 dot
   
  // using sat instead, since it's free, but compensating by brighting specular
  half specK = saturate( rsqrt( saturate( NdotL * NdotE ) ) );			  	                          // 1 rcp, 1 mul
  specK *= NdotL * vExpDist.x * vExpDist.y;                                                         // 3 muls
                 
  return pow(specK, max(Exp, 0.0001)); 	 // # temporary solution #
  
  // 18 alu  
}

half WardAnisotropic_opt(half3 T, half3 B, half3 N, half3 V, half3 L, half NdotL, half NdotE, half2 vSurfaceRoughness, half Exp)
{
  // opt: averaging vectors instead of normalization
  //half3 H =  (V + L)*  0.5;                                        // 1 alu
  half3 H =  normalize(V + L);                                        // 1 alu


  half NdotH = dot( N, H );                                                    // 1 alu

  half2 HdotT_B = ( half2( dot( H, B ), dot( H, T ) ) )* vSurfaceRoughness.xy;                 // 3 alu
  HdotT_B *= HdotT_B;                                                                             // 1 alu

  // using sat instead, since it's free, but compensating by brighting specular
  half specK = saturate( rsqrt( saturate( NdotL * NdotE ) ) );                                 // 2 alu

  // opt: merged exponential with power factor
  //specK *= NdotL * exp( Exp* (-2.0 * (HdotT_B.x + HdotT_B.y) )/(1.001 + NdotH) );  // 6 alu
  specK *= NdotL * exp( dot(HdotT_B.xy, -2.0h * Exp/(1.001h + NdotH)) );  // 6 alu

  return specK;

  // 14 alu  
}

//////////////////////////////// Banks model, anisotropic /////////////////////////
// - Banks anisotropic model has Good properties for disk shape anisotropic 
// highlights (good for metallic surfaces)
// - Very cheap

half BanksAnisotropic(half3 T, half3 V, half3 L, half Exp)	
{
    half LdotT = dot( L, T );																		// 1 dot
    half VdotT = dot( V, T );																		// 1 dot
        
    half fSpec = sqrt( 1 - LdotT * LdotT );														// 1 mad, 1 rcp		
    fSpec *= sqrt( 1 - VdotT * VdotT );																// 1 mul, 1 mad, 1 rcp
    fSpec = saturate( fSpec - LdotT * VdotT );
      
  return pow(fSpec, Exp);																			// 1 pow
  
  // aprox 8 ALU
}

half BanksAnisotropicTex(half3 T, half3 V, half3 L, half Exp)	
{
  // Todo
  
  return 1;
  
  // 1 ALU, 1 TEX
}

//////////////////////////////// Kajiya-Kay model, anisotropic /////////////////////////
// - Kajiya-Kay anisotropic model has Good properties for radial shape anisotropic 
// highlights (good for hair)
// - Very cheap

half KajiyaKayAnisotropic(half3 T, half3 V, half3 L, half Exp)
{
  half3 H = normalize( V + L );																// 4 alu
  half TdotH = dot( T, H );																		// 1 dot
  
  half fSpec = sqrt( max( 1.0 - TdotH * TdotH, 0.01) );										// 1 mad, 1 sqrt
  
  return pow( fSpec, Exp );																	  	// 3 alu
  
  // aprox 10 ALU
}

// A bit cheaper version, half vector already pre-computed
half KajiyaKayAnisotropic(half3 T, half3 H, half Exp)
{	
  half TdotH = dot( T, H );																  // 1 dot	
  half fSpec = sqrt( max( 1.0 - TdotH * TdotH, 0.01) );							    // 1 mad, 1 sqrt
  
  return pow( fSpec, Exp );																		// 3 alu
  
  // aprox 6 ALU		
}

//////////////////////////////// Kajiya-Kay model, anisotropic /////////////////////////
// - Oren-Nayar model has good properties for very rough surfaces (eg: sand, paper, cloth). 
// - Expensive

half OrenNayar(half3 N, half3 V, half3 L, half Exp)
{

  // Todo
  
  return 1;

}

half OrenNayarTex(half3 N, half3 V, half3 L, half Exp)
{

  // Todo
  
  return 1;

}
//////////////////////////////// Vegetation shading ////////////////

// Common vegetation shading

half3 LeafShadingBack(half3 vEye, half3 vLight, half3 vNormal, half3 cDiffBackK, half backViewDep)
{            
  half EdotL=saturate(dot(vEye.xyz, -vLight.xyz));          
  
  // Tweaked NdotL wrapping - Artists request
  half fLdotNBack=saturate(dot(vNormal.xyz, vLight.xyz)*0.6+0.4);

  half powEdotL = EdotL*EdotL;
  powEdotL *= powEdotL;
    
  half3 vBackShading = saturate(powEdotL*backViewDep + (1.0-backViewDep) * fLdotNBack);    

  return vBackShading * cDiffBackK.xyz;
}   

void LeafShadingFront(half3 vEye, half3 vLight, half3 vNormal, half3 cDifK, half3 cSpecK, inout half3 outDif, inout half3 outSpec, half fSpecularExp)
{                                                                                                                                  
  half fLdotNFront=dot(vNormal.xyz, vLight.xyz);      
  // Compute front diffuse term  
#if %GRASS   
  outDif=max(fLdotNFront, 0.5)*cDifK.xyz; 
#else
  outDif=saturate(fLdotNFront)*cDifK.xyz;
#endif
  // compute specular if necessary 
#if !%GRASS
  outSpec= Phong(vEye, vLight, fSpecularExp) * cSpecK.xyz;  
#endif
}

// Common SH vegetation shading

//simple sin approx for 2 at a time
float2 ApproxSine2(float2 arg)
{ 
  #define PI 3.14159265
  float2 x = frac(arg/(2.0*PI)+0.5)*2.0*PI-PI;//brings into -pi..pi, same instr. generated as for sincos
  float2 x3 = x * x * x;  //cubic component
  float a = -8.0/(3*PI*PI*PI);	//constant
  float c = 8.0/(3*PI);			//constant
  return (a*x3 + c*x); //4 at once, how fast can it get...
}

//simple sin approx for 4 at a time
float4 ApproxSine4(float4 arg)
{ 
  #define PI 3.14159265
  float4 x = frac(arg/(2.0*PI)+0.5)*2.0*PI-PI;//brings into -pi..pi, same instr. generated as for sincos
  float4 x3 = x * x * x;  //cubic component
  float a = -8.0/(3*PI*PI*PI);	//constant
  float c = 8.0/(3*PI);			//constant
  return (a*x3 + c*x); //4 at once, how fast can it get...
}

float DoSHLookup(float3 vDir, float4 SHShadowing[2])
{
  float4 tempSH0 = float4(vDir,1);//use normalized object space light vector as query input
  float2 tempSH1 = float2(dot(tempSH0, SHShadowing[0]),0);
  float4 tempSH3 = tempSH0.xyzz * tempSH0.yzzx;
  tempSH0.xy *= tempSH0.xy;
  tempSH3.x = tempSH0.x - tempSH0.y;
  tempSH1.y = dot(tempSH3, SHShadowing[1]);
  return (tempSH1.x + tempSH1.y);
}

//============================================================================================



float2 ParallaxOcclusionMap(in float2 baseTC, in float lod, in float3 viewDirNrm, in int numSteps, in float displacement)
{
	float step =  1.0 / numSteps;
	float bumpScale = displacement;
	
	float2 delta = float2(viewDirNrm.x, viewDirNrm.y) * bumpScale / (-viewDirNrm.z * numSteps); // / max(-viewDirNrm.z * numSteps, 0.1)
		
	float4 NB0 = tex2D(bumpHeightMapSampler, baseTC);
			
	float height = 1 - step;
	float4 offset = float4(baseTC + delta, 0, lod);
	float4 NB1 = tex2D(bumpHeightMapSampler, offset);

	for (int i=0; i<numSteps; i++)
	{
#ifndef XENON
		[flatten]
#endif
		if (NB1.w >= height)
			break;
			
		NB0 = NB1;

		height -= step;
		offset.xy += delta;

		NB1 = tex2Dlod(bumpHeightMapSampler, offset);
	}
	
	float4 offsetBest = offset;
	float error = 1.0;

	float t1 = height;
	float t0 = t1 + step;
	
	float delta1 = t1 - NB1.w;
	float delta0 = t0 - NB0.w;

	float4 intersect = float4(delta * numSteps, delta * numSteps + baseTC);

	/*for (int i=0; i<10; i++)
	{
#ifndef XENON
		[flatten]
#endif
		if (abs(error) <= 0.01)
			break;
	
		float denom = delta1 - delta0;
		float t = (t0 * delta1 - t1 * delta0) / denom;
		offsetBest.xy = -t * intersect.xy + intersect.zw;
		
		float4 NB = tex2Dlod(bumpHeightMapSampler, offsetBest);

		error = t - NB.w;
		if (error < 0)
		{
			delta1 = error;
			t1 = t;
		}
		else
		{
			delta0 = error;
			t0 = t;
		}
	}*/
	
	return offsetBest.xy;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// HDR output

void HDRFogOutput( out pixout OUT, half4 Color, half fDepth, half3 FogColor, half fFogFactor )
{
  Color.xyz = lerp(FogColor.xyz, Color.xyz, fFogFactor);
  OUT.Color = Color;

#if %_RT_HDR_ENCODE  
  OUT.Color = EncodeRGBK(OUT.Color, SCENE_HDR_MULTIPLIER);
#endif
}

void HDROutput( out pixout OUT, half4 Color, half fDepth)
{
  OUT.Color = Color;

#if %_RT_HDR_ENCODE  
  OUT.Color = EncodeRGBK(OUT.Color, SCENE_HDR_MULTIPLIER);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// EnvMap Samplers
////////////////////////////////////////////////////////////////////////////////////////////////////

half4 GetEnvironmentCMap(samplerCUBE envMap, in half3 envTC, in half fSpecPower)
{
	//half fGlossinessLod = 8.h + log2(1.h-exp2(-1.h/fSpecPower));
	// Approximation is used instead for the sake of performance ( 5 alu less )
	half fGlossinessLod = 6.16231h - 0.497418h * sqrt(fSpecPower);
  half4 envColor = DecodeRGBK(texCUBElod( envMap, half4(envTC, fGlossinessLod) ), HDR_FAKE_MAXOVERBRIGHT);
  
/* - feature cutted
if %_RT_REALTIMECM   
  envColor = DecodeRGBK(envColor, HDR_FAKE_MAXOVERBRIGHT);
  if !%_RT_HDR_MODE  
    envColor = 1 - exp(-0.5*envColor);
  endif
endif
*/
  
  return envColor;
}

half4 GetEnvironment2DMap(sampler2D envMap, in half2 envTC)
{
  half4 envColor = tex2D(envMap, envTC.xy);
  
/* - feature cutted
if %_RT_REALTIMECM   

  envColor = DecodeRGBK(envColor, HDR_FAKE_MAXOVERBRIGHT);
  if !%_RT_HDR_MODE  
    envColor = 1 - exp(-0.5*envColor);
  endif
  
endif
*/  
  return envColor;
}
