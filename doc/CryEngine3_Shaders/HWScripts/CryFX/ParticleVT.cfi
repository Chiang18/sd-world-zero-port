////////////////////////////////////////////////
// shader constants

float4 GlowParams           : PB_GlowParams;
float4 TexTileSize          : PI_TextureTileSize;	// xy = tile width/height, z = tile count, w = start

float4 CameraRightVector		: PB_CameraRight;
float4 CameraUpVector				: PB_CameraUp;
float4 CameraFrontVector		: PB_CameraFront;

struct app2vertParticleGeneral
{
  float4 Position  : POSITION; //in object space  
  float4 Color     : COLOR0;
  float4 baseTC    : COLOR1;
  float4 ScreenRot : PSIZE0;
};

// add other required stuff here
struct vert2FragParticleGeneral
{
  float4 Position  : POSITION;  //in projection space
  
#ifdef %_RT_SOFT_PARTICLE
  float4 hPosTexProj  : TEXCOORDN;
  float4 particleFade : TEXCOORDN;
#endif
};

float3 Particle_Convert_TC( float3 baseTC )
{
	// Apply tiling params to TCs
	float3 outTC = baseTC.xyz * TexTileSize.xyz;
	outTC.z += TexTileSize.w;
	float tileX = floor(outTC.z) * TexTileSize.x;
	outTC.x += frac(tileX);
	outTC.y += floor(tileX) * TexTileSize.y;
	return outTC;
}

void Particle_Setup_Tangents(inout float4 vPos, out float3x3 tangentSpace, float4x4 mViewProj, inout app2vertParticleGeneral IN, out vert2FragParticleGeneral OUT)
{
  #ifdef D3D10 || PS3 || XENON
  #else
		// PC DX9 swap only
    IN.baseTC.xyzw = IN.baseTC.zyxw;
  #endif

  //////////////////////////////////////////////////////
  // coord expansion.

	// Apply TCs to axes
	IN.ScreenRot.xy *= 2.0*IN.baseTC.x - 1.0;
	IN.ScreenRot.zw *= 1.0 - 2.0*IN.baseTC.y;

	// Apply axes to tangent space
  tangentSpace[2] = normalize( vfViewPos - vPos );
  float3 r = cross( CameraUpVector.xyz, tangentSpace[2] );
  float3 u = cross( tangentSpace[2], r );
  
  tangentSpace[0] = r * IN.ScreenRot.x + u * IN.ScreenRot.y;
  tangentSpace[1] = -(r * IN.ScreenRot.z + u * IN.ScreenRot.w);

  vPos.xyz += tangentSpace[0] - tangentSpace[1];
  
  // Position in screen space.
  OUT.Position = mul(mViewProj, vPos);
  
  //////////////////////////////////////////////////////////////////////
  // soft particle setup
  
  #ifdef %_RT_SOFT_PARTICLE
    OUT.hPosTexProj = HPosToScreenTC(OUT.Position);

    float size = sqrt( abs(IN.ScreenRot.x*IN.ScreenRot.w - IN.ScreenRot.y*IN.ScreenRot.z) );
    float4 newPos = float4( vPos.xyz + size * CameraFrontVector.xyz, 1.0 );

    float hNewPosZ = dot( mViewProj[ 2 ], newPos );
    float hNewPosW = dot( mViewProj[ 3 ], newPos );
    OUT.Position.z = OUT.Position.w *( hNewPosZ / hNewPosW );

    if( hNewPosW < g_VS_NearFarClipDist.x && hNewPosW + size > g_VS_NearFarClipDist.x )
      OUT.Position.z = 0;

    float particleThicknessInv = 1.0 / ( 2.0 * size );
    float scaleCamera = ( hNewPosW + size - g_VS_NearFarClipDist.x ) * 2.0 * particleThicknessInv;
    OUT.particleFade.x = scaleCamera;
    OUT.particleFade.y = particleThicknessInv;
    OUT.particleFade.z = size;
    OUT.particleFade.w = hNewPosW;
  #endif     
}

void Particle_Setup_General(inout float4 vPos, float4x4 mViewProj, inout app2vertParticleGeneral IN, out vert2FragParticleGeneral OUT)
{
	float3x3 tangentSpace;
  Particle_Setup_Tangents( vPos, tangentSpace, mViewProj, IN, OUT );
}

//========================================================================
